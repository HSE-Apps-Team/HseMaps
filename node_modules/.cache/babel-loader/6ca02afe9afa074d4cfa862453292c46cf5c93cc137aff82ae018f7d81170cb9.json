{"ast":null,"code":"/**\r\n * PathTransitionHandler - Manages transitions between floor levels\r\n * Handles state changes during path traversal and prevents recursive updates\r\n * \r\n * @module PathTransitionHandler\r\n */\nimport { Config } from '../config/config.js';\nimport { StateManager } from './StateManager.js';\nimport { DataModule } from './DataModule.js';\nexport const PathTransitionHandler = {\n  /** Flag to prevent recursive transition handling */\n  isTransitioning: false,\n  /**\r\n   * Handles state transitions during path traversal\r\n   * Manages transitions between floors and triggers appropriate callbacks\r\n   * \r\n   * @param {SVGGeometryElement} path - SVG path element being traversed\r\n   * @param {number} sliderValue - Current position along the path (0 to pathLength)\r\n   * @param {number} totalDistance - Total path distance including both floors\r\n   * @returns {boolean} True if transition occurred, false otherwise\r\n   * \r\n   * @example First floor to second floor\r\n   * // Given:\r\n   * path.getTotalLength() = 100\r\n   * sliderValue = 100          // At end of first floor\r\n   * totalDistance = 200\r\n   * StateManager.get('firstPathRendered') = true\r\n   * \r\n   * handleTransition(path, 100, 200)\r\n   * // Results in:\r\n   * // - firstPathRendered = false\r\n   * // - secondPathRendered = true\r\n   * // - onPathEnd() called\r\n   * // Returns: true\r\n   * \r\n   * @example Second floor to first floor\r\n   * // Given:\r\n   * path.getTotalLength() = 100\r\n   * sliderValue = 0           // At start of second floor\r\n   * totalDistance = 200\r\n   * StateManager.get('secondPathRendered') = true\r\n   * \r\n   * handleTransition(path, 0, 200)\r\n   * // Results in:\r\n   * // - firstPathRendered = true\r\n   * // - secondPathRendered = false\r\n   * // - onPathStart() called\r\n   * // Returns: true\r\n   * \r\n   * @example No transition needed\r\n   * // Given:\r\n   * sliderValue = 50         // Middle of current floor\r\n   * \r\n   * handleTransition(path, 50, 200)\r\n   * // Returns: false (no state change)\r\n   */\n  handleTransition(path, sliderValue, totalDistance) {\n    // Guard against recursive calls during state updates\n    if (this.isTransitioning) return false;\n    try {\n      this.isTransitioning = true;\n      const currentSegment = StateManager.get('currentPathSegment');\n      const fullPath = StateManager.get('path');\n      let a = fullPath[currentSegment] > Config.THRESHOLD.FLOOR_CHANGE;\n      if (fullPath[0] > Config.THRESHOLD.FLOOR_CHANGE) {\n        a = !a;\n      }\n      if (a && StateManager.get('firstPathRendered')) {\n        StateManager.set('firstPathRendered', false);\n        StateManager.set('secondPathRendered', true);\n        const onPathEnd = StateManager.get('onPathEnd');\n        if (onPathEnd) onPathEnd();\n        return true;\n      }\n\n      // Check for transition back to first floor\n      if (!a && StateManager.get('secondPathRendered')) {\n        StateManager.set('firstPathRendered', true);\n        StateManager.set('secondPathRendered', false);\n        const onPathStart = StateManager.get('onPathStart');\n        if (onPathStart) onPathStart();\n        return true;\n      }\n      return false;\n    } finally {\n      this.isTransitioning = false;\n    }\n  }\n};","map":{"version":3,"names":["Config","StateManager","DataModule","PathTransitionHandler","isTransitioning","handleTransition","path","sliderValue","totalDistance","currentSegment","get","fullPath","a","THRESHOLD","FLOOR_CHANGE","set","onPathEnd","onPathStart"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/PathTransitionHandler.js"],"sourcesContent":["/**\r\n * PathTransitionHandler - Manages transitions between floor levels\r\n * Handles state changes during path traversal and prevents recursive updates\r\n * \r\n * @module PathTransitionHandler\r\n */\r\nimport { Config } from '../config/config.js';\r\nimport { StateManager } from './StateManager.js';\r\nimport { DataModule } from './DataModule.js';\r\n\r\nexport const PathTransitionHandler = {\r\n    /** Flag to prevent recursive transition handling */\r\n    isTransitioning: false,\r\n\r\n    /**\r\n     * Handles state transitions during path traversal\r\n     * Manages transitions between floors and triggers appropriate callbacks\r\n     * \r\n     * @param {SVGGeometryElement} path - SVG path element being traversed\r\n     * @param {number} sliderValue - Current position along the path (0 to pathLength)\r\n     * @param {number} totalDistance - Total path distance including both floors\r\n     * @returns {boolean} True if transition occurred, false otherwise\r\n     * \r\n     * @example First floor to second floor\r\n     * // Given:\r\n     * path.getTotalLength() = 100\r\n     * sliderValue = 100          // At end of first floor\r\n     * totalDistance = 200\r\n     * StateManager.get('firstPathRendered') = true\r\n     * \r\n     * handleTransition(path, 100, 200)\r\n     * // Results in:\r\n     * // - firstPathRendered = false\r\n     * // - secondPathRendered = true\r\n     * // - onPathEnd() called\r\n     * // Returns: true\r\n     * \r\n     * @example Second floor to first floor\r\n     * // Given:\r\n     * path.getTotalLength() = 100\r\n     * sliderValue = 0           // At start of second floor\r\n     * totalDistance = 200\r\n     * StateManager.get('secondPathRendered') = true\r\n     * \r\n     * handleTransition(path, 0, 200)\r\n     * // Results in:\r\n     * // - firstPathRendered = true\r\n     * // - secondPathRendered = false\r\n     * // - onPathStart() called\r\n     * // Returns: true\r\n     * \r\n     * @example No transition needed\r\n     * // Given:\r\n     * sliderValue = 50         // Middle of current floor\r\n     * \r\n     * handleTransition(path, 50, 200)\r\n     * // Returns: false (no state change)\r\n     */\r\n    handleTransition(path, sliderValue, totalDistance) {\r\n        // Guard against recursive calls during state updates\r\n        if (this.isTransitioning) return false;\r\n        \r\n        try {\r\n            this.isTransitioning = true;\r\n            const currentSegment = StateManager.get('currentPathSegment');\r\n            const fullPath = StateManager.get('path');\r\n            let a = fullPath[currentSegment]>Config.THRESHOLD.FLOOR_CHANGE;\r\n            if(fullPath[0]>Config.THRESHOLD.FLOOR_CHANGE){\r\n                a = !a;\r\n            }\r\n            \r\n\r\n            \r\n            if (a && \r\n                StateManager.get('firstPathRendered')) {\r\n                StateManager.set('firstPathRendered', false);\r\n                StateManager.set('secondPathRendered', true);\r\n                const onPathEnd = StateManager.get('onPathEnd');\r\n                if (onPathEnd) onPathEnd();\r\n                return true;\r\n            }\r\n            \r\n            // Check for transition back to first floor\r\n            if (!a && StateManager.get('secondPathRendered')) {\r\n                StateManager.set('firstPathRendered', true);\r\n                StateManager.set('secondPathRendered', false);\r\n                const onPathStart = StateManager.get('onPathStart');\r\n                if (onPathStart) onPathStart();\r\n                return true;\r\n            }\r\n            \r\n            return false;\r\n        } finally {\r\n            this.isTransitioning = false;\r\n        }\r\n    }\r\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,qBAAqB;AAC5C,SAASC,YAAY,QAAQ,mBAAmB;AAChD,SAASC,UAAU,QAAQ,iBAAiB;AAE5C,OAAO,MAAMC,qBAAqB,GAAG;EACjC;EACAC,eAAe,EAAE,KAAK;EAEtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,gBAAgBA,CAACC,IAAI,EAAEC,WAAW,EAAEC,aAAa,EAAE;IAC/C;IACA,IAAI,IAAI,CAACJ,eAAe,EAAE,OAAO,KAAK;IAEtC,IAAI;MACA,IAAI,CAACA,eAAe,GAAG,IAAI;MAC3B,MAAMK,cAAc,GAAGR,YAAY,CAACS,GAAG,CAAC,oBAAoB,CAAC;MAC7D,MAAMC,QAAQ,GAAGV,YAAY,CAACS,GAAG,CAAC,MAAM,CAAC;MACzC,IAAIE,CAAC,GAAGD,QAAQ,CAACF,cAAc,CAAC,GAACT,MAAM,CAACa,SAAS,CAACC,YAAY;MAC9D,IAAGH,QAAQ,CAAC,CAAC,CAAC,GAACX,MAAM,CAACa,SAAS,CAACC,YAAY,EAAC;QACzCF,CAAC,GAAG,CAACA,CAAC;MACV;MAIA,IAAIA,CAAC,IACDX,YAAY,CAACS,GAAG,CAAC,mBAAmB,CAAC,EAAE;QACvCT,YAAY,CAACc,GAAG,CAAC,mBAAmB,EAAE,KAAK,CAAC;QAC5Cd,YAAY,CAACc,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAAC;QAC5C,MAAMC,SAAS,GAAGf,YAAY,CAACS,GAAG,CAAC,WAAW,CAAC;QAC/C,IAAIM,SAAS,EAAEA,SAAS,CAAC,CAAC;QAC1B,OAAO,IAAI;MACf;;MAEA;MACA,IAAI,CAACJ,CAAC,IAAIX,YAAY,CAACS,GAAG,CAAC,oBAAoB,CAAC,EAAE;QAC9CT,YAAY,CAACc,GAAG,CAAC,mBAAmB,EAAE,IAAI,CAAC;QAC3Cd,YAAY,CAACc,GAAG,CAAC,oBAAoB,EAAE,KAAK,CAAC;QAC7C,MAAME,WAAW,GAAGhB,YAAY,CAACS,GAAG,CAAC,aAAa,CAAC;QACnD,IAAIO,WAAW,EAAEA,WAAW,CAAC,CAAC;QAC9B,OAAO,IAAI;MACf;MAEA,OAAO,KAAK;IAChB,CAAC,SAAS;MACN,IAAI,CAACb,eAAe,GAAG,KAAK;IAChC;EACJ;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}