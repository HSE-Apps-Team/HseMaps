{"ast":null,"code":"/**\r\n * PathfindingModule - Handles path construction and node selection for navigation\r\n * Provides methods for finding optimal paths between rooms and reconstructing paths\r\n * from precomputed matrices\r\n * \r\n * @module PathfindingModule\r\n */export const PathfindingModule={/**\r\n     * Constructs a path between two vertices using a next-vertex matrix\r\n     * @param {number[][]} nextMatrix - Matrix containing next vertex in shortest path\r\n     * @param {number} u - Starting vertex index\r\n     * @param {number} v - Ending vertex index\r\n     * @returns {number[]} Array of vertex indices forming the path\r\n     * \r\n     * @example\r\n     * // Given nextMatrix:\r\n     * // [[0, 1, 2],\r\n     * //  [1, 1, 2],\r\n     * //  [2, 2, 2]]\r\n     * constructPath(nextMatrix, 0, 2)\r\n     * // Returns: [0, 1, 2]\r\n     * \r\n     * @example Edge case - no path exists\r\n     * constructPath(nextMatrix, 0, 3)\r\n     * // Returns: []\r\n     */constructPath(nextMatrix,u,v){var _nextMatrix$u;if(!((_nextMatrix$u=nextMatrix[u])!==null&&_nextMatrix$u!==void 0&&_nextMatrix$u[v]))return[];const path=[u];while(path[path.length-1]!==v){const next=nextMatrix[path[path.length-1]][v];if(!next&&next!==0)break;path.push(next);}return path;},/**\r\n     * Selects the best node from a set based on minimum distance to goal nodes\r\n     * @param {number[]} nodes - Array of candidate node indices\r\n     * @param {number[]} goalNodes - Array of target node indices\r\n     * @param {number[][]} distMatrix - Matrix of distances between nodes\r\n     * @returns {number|null} Index of best node or null if no valid node found\r\n     * \r\n     * @example\r\n     * // Given distMatrix:\r\n     * // [[0, 5, Infinity],\r\n     * //  [5, 0, 3],\r\n     * //  [Infinity, 3, 0]]\r\n     * selectBestNode([0, 1], [2], distMatrix)\r\n     * // Returns: 1 (node 1 has shortest path to goal node 2)\r\n     * \r\n     * @example No valid path\r\n     * selectBestNode([0], [2], distMatrix)\r\n     * // Returns: null (no path from node 0 to goal node 2)\r\n     */selectBestNode(nodes,goalNodes,distMatrix){return nodes.reduce((best,node)=>{const minDist=Math.min(...goalNodes.map(goal=>{var _distMatrix$node$goal,_distMatrix$node;return(_distMatrix$node$goal=(_distMatrix$node=distMatrix[node])===null||_distMatrix$node===void 0?void 0:_distMatrix$node[goal])!==null&&_distMatrix$node$goal!==void 0?_distMatrix$node$goal:Infinity;}));return minDist<best.dist?{node,dist:minDist}:best;},{node:null,dist:Infinity}).node;},/**\r\n     * Finds shortest path between two rooms using precomputed matrices\r\n     * @param {number[][]} nextMatrix - Matrix containing next vertex in shortest path\r\n     * @param {number[][]} distMatrix - Matrix of distances between nodes\r\n     * @param {string} startRoom - Starting room identifier\r\n     * @param {string} endRoom - Destination room identifier\r\n     * @param {Object<string, number[]>} rooms - Map of room IDs to vertex indices\r\n     * @returns {number[]} Array of vertex indices forming the shortest path\r\n     * \r\n     * @example\r\n     * // Given room mapping:\r\n     * // rooms = { \"ROOM101\": [0, 1], \"ROOM102\": [2] }\r\n     * minPathBtwRooms(nextMatrix, distMatrix, \"ROOM101\", \"ROOM102\", rooms)\r\n     * // Returns: [1, 2] (shortest path from ROOM101 to ROOM102)\r\n     * \r\n     * @example No valid path\r\n     * minPathBtwRooms(nextMatrix, distMatrix, \"ROOM101\", \"ROOM999\", rooms)\r\n     * // Returns: [] (no path exists or invalid room)\r\n     */minPathBtwRooms(nextMatrix,distMatrix,startRoom,endRoom,rooms){const startNode=this.selectBestNode(rooms[startRoom],rooms[endRoom],distMatrix);const endNode=this.selectBestNode(rooms[endRoom],[startNode],distMatrix);return this.constructPath(nextMatrix,startNode,endNode);}};","map":{"version":3,"names":["PathfindingModule","constructPath","nextMatrix","u","v","_nextMatrix$u","path","length","next","push","selectBestNode","nodes","goalNodes","distMatrix","reduce","best","node","minDist","Math","min","map","goal","_distMatrix$node$goal","_distMatrix$node","Infinity","dist","minPathBtwRooms","startRoom","endRoom","rooms","startNode","endNode"],"sources":["C:/Users/ampri/OneDrive/Documents/HseMaps/HseMaps/src/modules/PathfindingModule.js"],"sourcesContent":["/**\r\n * PathfindingModule - Handles path construction and node selection for navigation\r\n * Provides methods for finding optimal paths between rooms and reconstructing paths\r\n * from precomputed matrices\r\n * \r\n * @module PathfindingModule\r\n */\r\nexport const PathfindingModule = {\r\n    /**\r\n     * Constructs a path between two vertices using a next-vertex matrix\r\n     * @param {number[][]} nextMatrix - Matrix containing next vertex in shortest path\r\n     * @param {number} u - Starting vertex index\r\n     * @param {number} v - Ending vertex index\r\n     * @returns {number[]} Array of vertex indices forming the path\r\n     * \r\n     * @example\r\n     * // Given nextMatrix:\r\n     * // [[0, 1, 2],\r\n     * //  [1, 1, 2],\r\n     * //  [2, 2, 2]]\r\n     * constructPath(nextMatrix, 0, 2)\r\n     * // Returns: [0, 1, 2]\r\n     * \r\n     * @example Edge case - no path exists\r\n     * constructPath(nextMatrix, 0, 3)\r\n     * // Returns: []\r\n     */\r\n    constructPath(nextMatrix, u, v) {\r\n        if (!nextMatrix[u]?.[v]) return [];\r\n        const path = [u];\r\n        while (path[path.length - 1] !== v) {\r\n            const next = nextMatrix[path[path.length - 1]][v];\r\n            if (!next && next !== 0) break;\r\n            path.push(next);\r\n        }\r\n        return path;\r\n    },\r\n\r\n    /**\r\n     * Selects the best node from a set based on minimum distance to goal nodes\r\n     * @param {number[]} nodes - Array of candidate node indices\r\n     * @param {number[]} goalNodes - Array of target node indices\r\n     * @param {number[][]} distMatrix - Matrix of distances between nodes\r\n     * @returns {number|null} Index of best node or null if no valid node found\r\n     * \r\n     * @example\r\n     * // Given distMatrix:\r\n     * // [[0, 5, Infinity],\r\n     * //  [5, 0, 3],\r\n     * //  [Infinity, 3, 0]]\r\n     * selectBestNode([0, 1], [2], distMatrix)\r\n     * // Returns: 1 (node 1 has shortest path to goal node 2)\r\n     * \r\n     * @example No valid path\r\n     * selectBestNode([0], [2], distMatrix)\r\n     * // Returns: null (no path from node 0 to goal node 2)\r\n     */\r\n    selectBestNode(nodes, goalNodes, distMatrix) {\r\n        return nodes.reduce((best, node) => {\r\n            const minDist = Math.min(...goalNodes.map(goal => \r\n                distMatrix[node]?.[goal] ?? Infinity\r\n            ));\r\n            return minDist < best.dist ? { node, dist: minDist } : best;\r\n        }, { node: null, dist: Infinity }).node;\r\n    },\r\n\r\n    /**\r\n     * Finds shortest path between two rooms using precomputed matrices\r\n     * @param {number[][]} nextMatrix - Matrix containing next vertex in shortest path\r\n     * @param {number[][]} distMatrix - Matrix of distances between nodes\r\n     * @param {string} startRoom - Starting room identifier\r\n     * @param {string} endRoom - Destination room identifier\r\n     * @param {Object<string, number[]>} rooms - Map of room IDs to vertex indices\r\n     * @returns {number[]} Array of vertex indices forming the shortest path\r\n     * \r\n     * @example\r\n     * // Given room mapping:\r\n     * // rooms = { \"ROOM101\": [0, 1], \"ROOM102\": [2] }\r\n     * minPathBtwRooms(nextMatrix, distMatrix, \"ROOM101\", \"ROOM102\", rooms)\r\n     * // Returns: [1, 2] (shortest path from ROOM101 to ROOM102)\r\n     * \r\n     * @example No valid path\r\n     * minPathBtwRooms(nextMatrix, distMatrix, \"ROOM101\", \"ROOM999\", rooms)\r\n     * // Returns: [] (no path exists or invalid room)\r\n     */\r\n    minPathBtwRooms(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\r\n        const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\r\n        const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\r\n        return this.constructPath(nextMatrix, startNode, endNode);\r\n    }\r\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAA,iBAAiB,CAAG,CAC7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACIC,aAAaA,CAACC,UAAU,CAAEC,CAAC,CAAEC,CAAC,CAAE,KAAAC,aAAA,CAC5B,GAAI,GAAAA,aAAA,CAACH,UAAU,CAACC,CAAC,CAAC,UAAAE,aAAA,WAAbA,aAAA,CAAgBD,CAAC,CAAC,EAAE,MAAO,EAAE,CAClC,KAAM,CAAAE,IAAI,CAAG,CAACH,CAAC,CAAC,CAChB,MAAOG,IAAI,CAACA,IAAI,CAACC,MAAM,CAAG,CAAC,CAAC,GAAKH,CAAC,CAAE,CAChC,KAAM,CAAAI,IAAI,CAAGN,UAAU,CAACI,IAAI,CAACA,IAAI,CAACC,MAAM,CAAG,CAAC,CAAC,CAAC,CAACH,CAAC,CAAC,CACjD,GAAI,CAACI,IAAI,EAAIA,IAAI,GAAK,CAAC,CAAE,MACzBF,IAAI,CAACG,IAAI,CAACD,IAAI,CAAC,CACnB,CACA,MAAO,CAAAF,IAAI,CACf,CAAC,CAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACII,cAAcA,CAACC,KAAK,CAAEC,SAAS,CAAEC,UAAU,CAAE,CACzC,MAAO,CAAAF,KAAK,CAACG,MAAM,CAAC,CAACC,IAAI,CAAEC,IAAI,GAAK,CAChC,KAAM,CAAAC,OAAO,CAAGC,IAAI,CAACC,GAAG,CAAC,GAAGP,SAAS,CAACQ,GAAG,CAACC,IAAI,OAAAC,qBAAA,CAAAC,gBAAA,QAAAD,qBAAA,EAAAC,gBAAA,CAC1CV,UAAU,CAACG,IAAI,CAAC,UAAAO,gBAAA,iBAAhBA,gBAAA,CAAmBF,IAAI,CAAC,UAAAC,qBAAA,UAAAA,qBAAA,CAAIE,QAAQ,EACxC,CAAC,CAAC,CACF,MAAO,CAAAP,OAAO,CAAGF,IAAI,CAACU,IAAI,CAAG,CAAET,IAAI,CAAES,IAAI,CAAER,OAAQ,CAAC,CAAGF,IAAI,CAC/D,CAAC,CAAE,CAAEC,IAAI,CAAE,IAAI,CAAES,IAAI,CAAED,QAAS,CAAC,CAAC,CAACR,IAAI,CAC3C,CAAC,CAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACIU,eAAeA,CAACxB,UAAU,CAAEW,UAAU,CAAEc,SAAS,CAAEC,OAAO,CAAEC,KAAK,CAAE,CAC/D,KAAM,CAAAC,SAAS,CAAG,IAAI,CAACpB,cAAc,CAACmB,KAAK,CAACF,SAAS,CAAC,CAAEE,KAAK,CAACD,OAAO,CAAC,CAAEf,UAAU,CAAC,CACnF,KAAM,CAAAkB,OAAO,CAAG,IAAI,CAACrB,cAAc,CAACmB,KAAK,CAACD,OAAO,CAAC,CAAE,CAACE,SAAS,CAAC,CAAEjB,UAAU,CAAC,CAC5E,MAAO,KAAI,CAACZ,aAAa,CAACC,UAAU,CAAE4B,SAAS,CAAEC,OAAO,CAAC,CAC7D,CACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}