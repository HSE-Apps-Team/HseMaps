{"ast":null,"code":"import { Config } from '../config/config.js';\nimport { StateManager } from './StateManager.js';\nimport { DOMCache } from './DOMCache.js';\nimport { ColorModule } from './ColorModule.js';\nimport { PathTransitionHandler } from './PathTransitionHandler.js';\nimport { RenderingModule } from './RenderingModule.js';\nimport { DataModule } from './DataModule.js';\nimport { PathfindingModule } from './PathfindingModule.js';\nimport { StreetViewModule } from './StreetViewModule.js';\n\n/**\r\n * UtilityModule - Core functionality for agent movement and path tracking\r\n * Manages agent position updates, orientation calculations, and path transitions\r\n * \r\n * @module UtilityModule\r\n */\nexport const UtilityModule = {\n  /**\r\n  * Updates agent position and orientation on the SVG path\r\n  * Calculates rotation angle based on next point\r\n  * \r\n  * @param {SVGCircleElement} agent - Agent circle element\r\n  * @param {SVGPoint} point - Current point on path\r\n  * @param {SVGPoint} nextPoint - Next point for orientation\r\n  * @param {SVGElement} svg - SVG container element\r\n  * @param {number} margin - Viewport margin\r\n  * \r\n  * @example\r\n  * // Given:\r\n  * point = {x: 100, y: 100}\r\n  * nextPoint = {x: 110, y: 110}\r\n  * \r\n  * updateAgentPosition(agent, point, nextPoint, svg, 300)\r\n  * // Results in:\r\n  * // - agent.cx.baseVal.value = 100\r\n  * // - agent.cy.baseVal.value = 100\r\n  * // - svg rotation = 315 degrees (pointing northeast)\r\n  * // - viewport centered on agent with 300px margin\r\n  */\n  updateAgentPosition(agent, point, nextPoint, svg, margin) {\n    agent.cx.baseVal.value = point.x;\n    agent.cy.baseVal.value = point.y;\n    RenderingModule.focus(agent, margin);\n    const orientation = 270 - Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x) * 180 / Math.PI;\n    svg.setAttribute(\"style\", `transform-origin: ${point.x}px ${point.y}px; transform: rotate(${orientation}deg)`);\n  },\n  /**\r\n   * Updates agent position, color, and orientation based on scroll progress\r\n   * Handles both first and second floor path transitions\r\n   * \r\n   * @param {number} margin - Viewport margin around agent\r\n   * \r\n   * @example First floor movement\r\n   * // Given:\r\n   * StateManager.get('secondPathRendered') = false\r\n   * progbar.value = 50\r\n   * progbar.max = 200\r\n   * path.getTotalLength() = 100\r\n   * \r\n   * updateAgent(300)\r\n   * // Results in:\r\n   * // - agent positioned at path.getPointAtLength(50)\r\n   * // - agent color = yellow (50/200 completion)\r\n   * // - viewport centered on agent with 300px margin\r\n   * \r\n   * @example Second floor transition\r\n   * // Given:\r\n   * StateManager.get('secondPathRendered') = true\r\n   * StateManager.get('totalDistance') = 200\r\n   * progbar.value = 150\r\n   * path.getTotalLength() = 100\r\n   * \r\n   * updateAgent()\r\n   * // Results in:\r\n   * // dist = -(200 - 150 - 100) = 50\r\n   * // - agent positioned at path.getPointAtLength(50)\r\n   * // - agent color = green (150/200 completion)\r\n   */\n  updateAgent(margin = Config.DEFAULTS.MARGIN) {\n    const elements = {\n      agent: DOMCache[Config.SVG.SELECTORS.AGENT],\n      path: DOMCache[`${Config.SVG.SELECTORS.GRAPH} > polyline`],\n      progbar: DOMCache[Config.SVG.SELECTORS.PROGBAR],\n      svg: DOMCache[Config.SVG.SELECTORS.SVGRAPH],\n      image: DOMCache[Config.SVG.SELECTORS.IMAGE]\n    };\n    if (!Object.values(elements).every(el => el === null || el === void 0 ? void 0 : el.isConnected)) return;\n    try {\n      const {\n        agent,\n        path,\n        progbar,\n        svg,\n        image\n      } = elements;\n      const sliderValue = progbar.value;\n      const sliderCompletion = sliderValue / progbar.max;\n      const distanceDomain = StateManager.get('distanceDomain');\n      const currentPathSegment = distanceDomain.findIndex((e, i) => sliderValue >= distanceDomain[i] && sliderValue < (distanceDomain[i + 1] || Infinity));\n      StateManager.set('currentPathSegment', currentPathSegment);\n      // Calculate distance based on floor\n      const dist = StateManager.get('secondPathRendered') ? -(StateManager.get('totalDistance') - sliderValue - path.getTotalLength()) : sliderValue;\n      const point = path.getPointAtLength(dist);\n      const nextPoint = path.getPointAtLength(Number(dist) + 10);\n      this.updateAgentPosition(agent, point, nextPoint, svg, margin);\n      agent.style.fill = ColorModule.getColor(sliderCompletion);\n      PathTransitionHandler.handleTransition(path, sliderValue, StateManager.get('totalDistance'));\n      //image.href.baseVal = StreetViewModule.getImg();\n    } catch (error) {\n      console.error('Agent update failed:', error);\n    }\n  },\n  /**\r\n   * Calculates and renders shortest path between two locations\r\n   * Handles floor transitions and stairwell detection\r\n   * \r\n   * @param {string} start - Starting room identifier (e.g., \"ROOM101\")\r\n   * @param {string} end - Destination room identifier (e.g., \"ROOM201\")\r\n   * @returns {SVGPolylineElement} Created path element\r\n   * \r\n   * @example Single floor path\r\n   * // Given:\r\n   * start = \"ROOM101\"  // Room on first floor\r\n   * end = \"ROOM102\"    // Room on first floor\r\n   * rooms = {\r\n   *   \"ROOM101\": [0],  // Vertex index 0\r\n   *   \"ROOM102\": [5]   // Vertex index 5\r\n   * }\r\n   * \r\n   * markShortestPath(\"ROOM101\", \"ROOM102\")\r\n   * // Results in:\r\n   * // - path = [0, 2, 4, 5]\r\n   * // - totalDistance = 150\r\n   * // - Returns: <polyline points=\"100,100 150,100...\"/>\r\n   * \r\n   * @example Floor transition path\r\n   * // Given:\r\n   * start = \"ROOM101\"  // First floor\r\n   * end = \"ROOM201\"    // Second floor\r\n   * distMatrix[4][5] >= Config.THRESHOLD.STAIR_DISTANCE\r\n   * \r\n   * markShortestPath(\"ROOM101\", \"ROOM201\")\r\n   * // Results in:\r\n   * // - First floor path rendered: [0, 2, 4]\r\n   * // - Stairwell transition registered at index 4\r\n   * // - onPathStart/End handlers set for floor transition\r\n   */\n  markShortestPath(start, end) {\n    RenderingModule.refresh();\n    StateManager.set('onPathEnd', () => {});\n    StateManager.set('onPathStart', () => {});\n    const {\n      nextMatrix,\n      distMatrix,\n      rooms,\n      verts\n    } = DataModule.get();\n    const path = PathfindingModule.minPathBtwRooms(nextMatrix, distMatrix, start, end, rooms);\n    StateManager.set('totalDistance', distMatrix[path[0]][path[path.length - 1]]);\n    StateManager.set('path', path);\n\n    // Recalculate distance domain to handle stairwells smoothly\n    const distanceDomain = [];\n    let accumulatedDist = 0;\n    for (let i = 0; i < path.length; i++) {\n      distanceDomain[i] = accumulatedDist;\n      if (i < path.length - 1 && distMatrix[path[i]][path[i + 1]] < Config.THRESHOLD.STAIR_DISTANCE) {\n        let segmentDist = distMatrix[path[i]][path[i + 1]];\n        // Don't subtract stair distance, just use actual segment length\n        accumulatedDist += segmentDist;\n      }\n    }\n    StateManager.set('distanceDomain', distanceDomain);\n    for (let i = 0; i < path.length - 1; i++) {\n      if (distMatrix[path[i]][path[i + 1]] === Config.THRESHOLD.STAIR_DISTANCE) {\n        this.handleStairTransition(path, i + 1, distMatrix, verts);\n        return RenderingModule.selectPath(path.slice(0, i + 1), verts, undefined, \"stairwell\");\n      }\n    }\n    return RenderingModule.selectPath(path, verts);\n  },\n  /**\r\n   * Configures state and handlers for floor transitions via stairwell\r\n   * Sets up callbacks for transitioning between floors and manages path segments\r\n   * \r\n   * @param {number[]} path - Array of vertex indices for complete path\r\n   * @param {number} index - Index where stair transition occurs\r\n   * @param {number[][]} distMatrix - Distance matrix between vertices\r\n   * @param {Object[]} verts - Array of vertex coordinates {x,y}\r\n   * \r\n   * @example Complete floor transition\r\n   * // Given:\r\n   * path = [0, 1, 4, 77, 80]    // 0-4 first floor, 77-80 second floor\r\n   * index = 3                    // Transition at vertex 77\r\n   * distMatrix = [              // Distance matrix with stair connection\r\n   *   [0, 5, Infinity, ...],\r\n   *   [5, 0, 10, ...],\r\n   *   ...\r\n   *   [Infinity, 10000, 0, ...]\r\n   * ]\r\n   * verts = [\r\n   *   {x: 100, y: 100},        // Vertex 0\r\n   *   {x: 150, y: 100},        // Vertex 1\r\n   *   {x: 150, y: 200}         // Vertex 4\r\n   *   // ... more vertices\r\n   * ]\r\n   * \r\n   * handleStairTransition(path, 3, distMatrix, verts)\r\n   * // Results in:\r\n   * \r\n   * // 1. Total distance adjustment:\r\n   * // totalDistance = originalDistance - distMatrix[4][77]\r\n   * \r\n   * // 2. onPathStart handler set:\r\n   * // When first floor revisited:\r\n   * // - Clears existing path\r\n   * // - Creates path: [0, 1, 4]\r\n   * // - Sets skipEnd=false, skipStart=true\r\n   * // - Configures scroll for new path\r\n   * \r\n   * // 3. onPathEnd handler set:\r\n   * // When reaching second floor:\r\n   * // - Clears existing path\r\n   * // - Creates path: [77, 80]\r\n   * // - Sets skipStart=false, skipEnd=true\r\n   * // - Configures scroll for new path\r\n   */\n  handleStairTransition(path, index, distMatrix, verts) {\n    StateManager.set('totalDistance', StateManager.get('totalDistance') - distMatrix[path[index - 1]][path[index]]);\n\n    // Configure handler for returning to first floor\n    StateManager.set('onPathStart', () => {\n      if (!StateManager.get('skipStart')()) {\n        RenderingModule.refresh();\n        StateManager.set('skipEnd', () => false);\n        StateManager.set('skipStart', () => true);\n\n        // Use path segment to determine first floor section\n        RenderingModule.selectPath(path.slice(0, index), verts, undefined, \"stairwell\");\n        this.configureScroll();\n      }\n    });\n\n    // Configure handler for transitioning to second floor\n    StateManager.set('onPathEnd', () => {\n      if (!StateManager.get('skipEnd')()) {\n        RenderingModule.refresh();\n        StateManager.set('skipStart', () => false);\n        StateManager.set('skipEnd', () => true);\n        RenderingModule.selectPath(path.slice(index), verts, \"stairwell\");\n        this.configureScroll();\n      }\n    });\n  },\n  /**\r\n   * Configures scroll container and progress slider based on path length\r\n   * Centers viewport on agent and synchronizes scroll height with path distance\r\n   * \r\n   * @example Basic configuration\r\n   * // Given:\r\n   * StateManager.get('totalDistance') = 500\r\n   * DOMCache[Config.SVG.SELECTORS.AGENT] = <circle cx=\"150\" cy=\"200\" r=\"10\"/>\r\n   * \r\n   * configureScroll()\r\n   * // Results in:\r\n   * // 1. Viewport adjustment:\r\n   * // - Centers on (150,200)\r\n   * // - Adds Config.DEFAULTS.MARGIN (300px) padding\r\n   * // - Sets viewBox to approximately (0,50,300,300)\r\n   * \r\n   * // 2. Scroll/Slider setup:\r\n   * // - slider.max = 500\r\n   * // - scroll.children[0].style.height = \"500px\"\r\n   * \r\n   * @example No agent element\r\n   * // Given:\r\n   * DOMCache[Config.SVG.SELECTORS.AGENT] = null\r\n   * \r\n   * configureScroll()\r\n   * // Returns early with no changes\r\n   * \r\n   * @example Path transition\r\n   * // During floor transition:\r\n   * // 1. Initial state:\r\n   * // - totalDistance = 800\r\n   * // - scroll height = 800px\r\n   * \r\n   * // 2. After stair transition:\r\n   * // - totalDistance reduced by stair distance\r\n   * // - totalDistance = 600\r\n   * configureScroll()\r\n   * // - scroll height updates to 600px\r\n   * // - slider.max = 600\r\n   * // - viewport re-centers on agent position\r\n   */\n  configureScroll() {\n    const element = DOMCache[Config.SVG.SELECTORS.AGENT];\n    if (!element) return;\n    RenderingModule.focus(element, Config.DEFAULTS.MARGIN);\n    const scroll = DOMCache[Config.SVG.SELECTORS.SCROLL];\n    const slider = DOMCache[Config.SVG.SELECTORS.PROGBAR];\n    slider.max = StateManager.get('totalDistance');\n    scroll.children[0].style.height = `${slider.max}px`;\n  }\n};","map":{"version":3,"names":["Config","StateManager","DOMCache","ColorModule","PathTransitionHandler","RenderingModule","DataModule","PathfindingModule","StreetViewModule","UtilityModule","updateAgentPosition","agent","point","nextPoint","svg","margin","cx","baseVal","value","x","cy","y","focus","orientation","Math","atan2","PI","setAttribute","updateAgent","DEFAULTS","MARGIN","elements","SVG","SELECTORS","AGENT","path","GRAPH","progbar","PROGBAR","SVGRAPH","image","IMAGE","Object","values","every","el","isConnected","sliderValue","sliderCompletion","max","distanceDomain","get","currentPathSegment","findIndex","e","i","Infinity","set","dist","getTotalLength","getPointAtLength","Number","style","fill","getColor","handleTransition","error","console","markShortestPath","start","end","refresh","nextMatrix","distMatrix","rooms","verts","minPathBtwRooms","length","accumulatedDist","THRESHOLD","STAIR_DISTANCE","segmentDist","handleStairTransition","selectPath","slice","undefined","index","configureScroll","element","scroll","SCROLL","slider","children","height"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/UtilityModule.js"],"sourcesContent":["import { Config } from '../config/config.js';\r\nimport { StateManager } from './StateManager.js';\r\nimport { DOMCache } from './DOMCache.js';\r\nimport { ColorModule } from './ColorModule.js';\r\nimport { PathTransitionHandler } from './PathTransitionHandler.js';\r\nimport { RenderingModule } from './RenderingModule.js';\r\nimport { DataModule } from './DataModule.js';\r\nimport { PathfindingModule } from './PathfindingModule.js';\r\nimport { StreetViewModule } from './StreetViewModule.js';\r\n\r\n/**\r\n * UtilityModule - Core functionality for agent movement and path tracking\r\n * Manages agent position updates, orientation calculations, and path transitions\r\n * \r\n * @module UtilityModule\r\n */\r\nexport const UtilityModule = {\r\n\r\n        /**\r\n     * Updates agent position and orientation on the SVG path\r\n     * Calculates rotation angle based on next point\r\n     * \r\n     * @param {SVGCircleElement} agent - Agent circle element\r\n     * @param {SVGPoint} point - Current point on path\r\n     * @param {SVGPoint} nextPoint - Next point for orientation\r\n     * @param {SVGElement} svg - SVG container element\r\n     * @param {number} margin - Viewport margin\r\n     * \r\n     * @example\r\n     * // Given:\r\n     * point = {x: 100, y: 100}\r\n     * nextPoint = {x: 110, y: 110}\r\n     * \r\n     * updateAgentPosition(agent, point, nextPoint, svg, 300)\r\n     * // Results in:\r\n     * // - agent.cx.baseVal.value = 100\r\n     * // - agent.cy.baseVal.value = 100\r\n     * // - svg rotation = 315 degrees (pointing northeast)\r\n     * // - viewport centered on agent with 300px margin\r\n     */\r\n        updateAgentPosition(agent, point, nextPoint, svg, margin) {\r\n            agent.cx.baseVal.value = point.x;\r\n            agent.cy.baseVal.value = point.y;\r\n            RenderingModule.focus(agent, margin);\r\n            \r\n            const orientation = 270 - (Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x) * 180 / Math.PI);\r\n            svg.setAttribute(\"style\", `transform-origin: ${point.x}px ${point.y}px; transform: rotate(${orientation}deg)`);\r\n        },\r\n    /**\r\n     * Updates agent position, color, and orientation based on scroll progress\r\n     * Handles both first and second floor path transitions\r\n     * \r\n     * @param {number} margin - Viewport margin around agent\r\n     * \r\n     * @example First floor movement\r\n     * // Given:\r\n     * StateManager.get('secondPathRendered') = false\r\n     * progbar.value = 50\r\n     * progbar.max = 200\r\n     * path.getTotalLength() = 100\r\n     * \r\n     * updateAgent(300)\r\n     * // Results in:\r\n     * // - agent positioned at path.getPointAtLength(50)\r\n     * // - agent color = yellow (50/200 completion)\r\n     * // - viewport centered on agent with 300px margin\r\n     * \r\n     * @example Second floor transition\r\n     * // Given:\r\n     * StateManager.get('secondPathRendered') = true\r\n     * StateManager.get('totalDistance') = 200\r\n     * progbar.value = 150\r\n     * path.getTotalLength() = 100\r\n     * \r\n     * updateAgent()\r\n     * // Results in:\r\n     * // dist = -(200 - 150 - 100) = 50\r\n     * // - agent positioned at path.getPointAtLength(50)\r\n     * // - agent color = green (150/200 completion)\r\n     */\r\n    updateAgent(margin = Config.DEFAULTS.MARGIN) {\r\n        const elements = {\r\n            agent: DOMCache[Config.SVG.SELECTORS.AGENT],\r\n            path: DOMCache[`${Config.SVG.SELECTORS.GRAPH} > polyline`],\r\n            progbar: DOMCache[Config.SVG.SELECTORS.PROGBAR],\r\n            svg: DOMCache[Config.SVG.SELECTORS.SVGRAPH],\r\n            image: DOMCache[Config.SVG.SELECTORS.IMAGE]\r\n        };\r\n\r\n        if (!Object.values(elements).every(el => el?.isConnected)) return;\r\n\r\n        try {\r\n            const { agent, path, progbar, svg, image } = elements;\r\n            const sliderValue = progbar.value;\r\n            const sliderCompletion = sliderValue / progbar.max;\r\n            \r\n            const distanceDomain = StateManager.get('distanceDomain');\r\n            const currentPathSegment = distanceDomain.findIndex((e,i) => \r\n                sliderValue >= distanceDomain[i] && sliderValue < (distanceDomain[i + 1] || Infinity)\r\n            );\r\n            StateManager.set('currentPathSegment', currentPathSegment);\r\n            // Calculate distance based on floor\r\n            const dist = StateManager.get('secondPathRendered')\r\n                ? -(StateManager.get('totalDistance') - sliderValue - path.getTotalLength())\r\n                : sliderValue;\r\n\r\n            const point = path.getPointAtLength(dist);\r\n            const nextPoint = path.getPointAtLength(Number(dist) + 10);\r\n            \r\n            this.updateAgentPosition(agent, point, nextPoint, svg, margin);\r\n            agent.style.fill = ColorModule.getColor(sliderCompletion);\r\n            \r\n            PathTransitionHandler.handleTransition(path, sliderValue, StateManager.get('totalDistance'));\r\n            //image.href.baseVal = StreetViewModule.getImg();\r\n        } catch (error) {\r\n            console.error('Agent update failed:', error);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calculates and renders shortest path between two locations\r\n     * Handles floor transitions and stairwell detection\r\n     * \r\n     * @param {string} start - Starting room identifier (e.g., \"ROOM101\")\r\n     * @param {string} end - Destination room identifier (e.g., \"ROOM201\")\r\n     * @returns {SVGPolylineElement} Created path element\r\n     * \r\n     * @example Single floor path\r\n     * // Given:\r\n     * start = \"ROOM101\"  // Room on first floor\r\n     * end = \"ROOM102\"    // Room on first floor\r\n     * rooms = {\r\n     *   \"ROOM101\": [0],  // Vertex index 0\r\n     *   \"ROOM102\": [5]   // Vertex index 5\r\n     * }\r\n     * \r\n     * markShortestPath(\"ROOM101\", \"ROOM102\")\r\n     * // Results in:\r\n     * // - path = [0, 2, 4, 5]\r\n     * // - totalDistance = 150\r\n     * // - Returns: <polyline points=\"100,100 150,100...\"/>\r\n     * \r\n     * @example Floor transition path\r\n     * // Given:\r\n     * start = \"ROOM101\"  // First floor\r\n     * end = \"ROOM201\"    // Second floor\r\n     * distMatrix[4][5] >= Config.THRESHOLD.STAIR_DISTANCE\r\n     * \r\n     * markShortestPath(\"ROOM101\", \"ROOM201\")\r\n     * // Results in:\r\n     * // - First floor path rendered: [0, 2, 4]\r\n     * // - Stairwell transition registered at index 4\r\n     * // - onPathStart/End handlers set for floor transition\r\n     */\r\n    markShortestPath(start, end) {\r\n        RenderingModule.refresh();\r\n        StateManager.set('onPathEnd', () => {});\r\n        StateManager.set('onPathStart', () => {});\r\n        \r\n        const { nextMatrix, distMatrix, rooms, verts } = DataModule.get();\r\n        const path = PathfindingModule.minPathBtwRooms(nextMatrix, distMatrix, start, end, rooms);\r\n        StateManager.set('totalDistance', distMatrix[path[0]][path[path.length - 1]]);\r\n        StateManager.set('path', path);\r\n\r\n        // Recalculate distance domain to handle stairwells smoothly\r\n        const distanceDomain = [];\r\n        let accumulatedDist = 0;\r\n        \r\n        for (let i = 0; i < path.length; i++) {\r\n            distanceDomain[i] = accumulatedDist;\r\n            if (i < path.length - 1 && distMatrix[path[i]][path[i + 1]] < Config.THRESHOLD.STAIR_DISTANCE) {\r\n                let segmentDist = distMatrix[path[i]][path[i + 1]];\r\n                // Don't subtract stair distance, just use actual segment length\r\n                accumulatedDist += segmentDist;\r\n            }\r\n        }\r\n        \r\n        StateManager.set('distanceDomain', distanceDomain);\r\n        for (let i = 0; i < path.length-1; i++) {\r\n            if (distMatrix[path[i]][path[i + 1]] === Config.THRESHOLD.STAIR_DISTANCE) {\r\n                this.handleStairTransition(path, i+1, distMatrix, verts);\r\n                return RenderingModule.selectPath(path.slice(0, i+1), verts, undefined, \"stairwell\");\r\n            }\r\n        }\r\n        return RenderingModule.selectPath(path, verts);\r\n    },\r\n\r\n    /**\r\n     * Configures state and handlers for floor transitions via stairwell\r\n     * Sets up callbacks for transitioning between floors and manages path segments\r\n     * \r\n     * @param {number[]} path - Array of vertex indices for complete path\r\n     * @param {number} index - Index where stair transition occurs\r\n     * @param {number[][]} distMatrix - Distance matrix between vertices\r\n     * @param {Object[]} verts - Array of vertex coordinates {x,y}\r\n     * \r\n     * @example Complete floor transition\r\n     * // Given:\r\n     * path = [0, 1, 4, 77, 80]    // 0-4 first floor, 77-80 second floor\r\n     * index = 3                    // Transition at vertex 77\r\n     * distMatrix = [              // Distance matrix with stair connection\r\n     *   [0, 5, Infinity, ...],\r\n     *   [5, 0, 10, ...],\r\n     *   ...\r\n     *   [Infinity, 10000, 0, ...]\r\n     * ]\r\n     * verts = [\r\n     *   {x: 100, y: 100},        // Vertex 0\r\n     *   {x: 150, y: 100},        // Vertex 1\r\n     *   {x: 150, y: 200}         // Vertex 4\r\n     *   // ... more vertices\r\n     * ]\r\n     * \r\n     * handleStairTransition(path, 3, distMatrix, verts)\r\n     * // Results in:\r\n     * \r\n     * // 1. Total distance adjustment:\r\n     * // totalDistance = originalDistance - distMatrix[4][77]\r\n     * \r\n     * // 2. onPathStart handler set:\r\n     * // When first floor revisited:\r\n     * // - Clears existing path\r\n     * // - Creates path: [0, 1, 4]\r\n     * // - Sets skipEnd=false, skipStart=true\r\n     * // - Configures scroll for new path\r\n     * \r\n     * // 3. onPathEnd handler set:\r\n     * // When reaching second floor:\r\n     * // - Clears existing path\r\n     * // - Creates path: [77, 80]\r\n     * // - Sets skipStart=false, skipEnd=true\r\n     * // - Configures scroll for new path\r\n     */\r\n    handleStairTransition(path, index, distMatrix, verts) {\r\n        StateManager.set('totalDistance', \r\n            StateManager.get('totalDistance') - distMatrix[path[index - 1]][path[index]]\r\n        );\r\n        \r\n        // Configure handler for returning to first floor\r\n        StateManager.set('onPathStart', () => {\r\n            if (!StateManager.get('skipStart')()) {\r\n                RenderingModule.refresh();\r\n                StateManager.set('skipEnd', () => false);\r\n                StateManager.set('skipStart', () => true);\r\n                \r\n                // Use path segment to determine first floor section\r\n                RenderingModule.selectPath(\r\n                    path.slice(0, index),\r\n                    verts, \r\n                    undefined, \r\n                    \"stairwell\"\r\n                );\r\n                this.configureScroll();\r\n            }\r\n        });\r\n\r\n        // Configure handler for transitioning to second floor\r\n        StateManager.set('onPathEnd', () => {\r\n            if (!StateManager.get('skipEnd')()) {\r\n                RenderingModule.refresh();\r\n                StateManager.set('skipStart', () => false);\r\n                StateManager.set('skipEnd', () => true);\r\n            \r\n                RenderingModule.selectPath(\r\n                    path.slice(index),\r\n                    verts,\r\n                    \"stairwell\"\r\n                );\r\n                this.configureScroll();\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Configures scroll container and progress slider based on path length\r\n     * Centers viewport on agent and synchronizes scroll height with path distance\r\n     * \r\n     * @example Basic configuration\r\n     * // Given:\r\n     * StateManager.get('totalDistance') = 500\r\n     * DOMCache[Config.SVG.SELECTORS.AGENT] = <circle cx=\"150\" cy=\"200\" r=\"10\"/>\r\n     * \r\n     * configureScroll()\r\n     * // Results in:\r\n     * // 1. Viewport adjustment:\r\n     * // - Centers on (150,200)\r\n     * // - Adds Config.DEFAULTS.MARGIN (300px) padding\r\n     * // - Sets viewBox to approximately (0,50,300,300)\r\n     * \r\n     * // 2. Scroll/Slider setup:\r\n     * // - slider.max = 500\r\n     * // - scroll.children[0].style.height = \"500px\"\r\n     * \r\n     * @example No agent element\r\n     * // Given:\r\n     * DOMCache[Config.SVG.SELECTORS.AGENT] = null\r\n     * \r\n     * configureScroll()\r\n     * // Returns early with no changes\r\n     * \r\n     * @example Path transition\r\n     * // During floor transition:\r\n     * // 1. Initial state:\r\n     * // - totalDistance = 800\r\n     * // - scroll height = 800px\r\n     * \r\n     * // 2. After stair transition:\r\n     * // - totalDistance reduced by stair distance\r\n     * // - totalDistance = 600\r\n     * configureScroll()\r\n     * // - scroll height updates to 600px\r\n     * // - slider.max = 600\r\n     * // - viewport re-centers on agent position\r\n     */\r\n    configureScroll() {\r\n        const element = DOMCache[Config.SVG.SELECTORS.AGENT];\r\n        if (!element) return;\r\n        \r\n        RenderingModule.focus(element, Config.DEFAULTS.MARGIN);\r\n        const scroll = DOMCache[Config.SVG.SELECTORS.SCROLL];\r\n        const slider = DOMCache[Config.SVG.SELECTORS.PROGBAR];\r\n        \r\n        slider.max = StateManager.get('totalDistance');\r\n        scroll.children[0].style.height = `${slider.max}px`;\r\n    }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}