{"ast":null,"code":"/**\r\n * @module PathfindingModule\r\n * @description Handles pathfinding algorithms and route calculations between rooms\r\n */\n\nexport const PathfindingModule = {\n  /**\r\n   * @function constructPath\r\n   * @param {Array<Array<number>>} nextMatrix - Next vertex matrix for path reconstruction\r\n   * @param {number} start - Starting vertex index\r\n   * @param {number} end - Ending vertex index\r\n   * @returns {number[]} Array of vertex indices forming the path\r\n   */\n  constructPath(nextMatrix, start, end) {\n    // Add validation for matrix and indices\n    if (!(nextMatrix !== null && nextMatrix !== void 0 && nextMatrix[start]) || !(nextMatrix !== null && nextMatrix !== void 0 && nextMatrix[end])) return [];\n    const path = [start];\n    let current = start;\n    const maxIterations = nextMatrix.length; // Prevent infinite loops\n    let iterations = 0;\n    while (current !== end && iterations < maxIterations) {\n      var _nextMatrix$current;\n      const next = (_nextMatrix$current = nextMatrix[current]) === null || _nextMatrix$current === void 0 ? void 0 : _nextMatrix$current[end];\n      if (next === undefined || next === null) break;\n      path.push(next);\n      current = next;\n      iterations++;\n    }\n\n    // Only return path if we actually reached the end\n    return path[path.length - 1] === end ? path : [];\n  },\n  /**\r\n   * @function selectBestNode\r\n   * @param {number[]} nodes - Array of candidate nodes\r\n   * @param {number[]} goalNodes - Array of possible goal nodes\r\n   * @param {Array<Array<number>>} distMatrix - Distance matrix between nodes\r\n   * @returns {number|null} Best node index or null if no valid node found\r\n   */\n  selectBestNode(nodes, goalNodes, distMatrix) {\n    if (!(nodes !== null && nodes !== void 0 && nodes.length) || !(goalNodes !== null && goalNodes !== void 0 && goalNodes.length)) return null;\n    return nodes.reduce((best, node) => {\n      const minDist = Math.min(...goalNodes.map(goal => {\n        var _distMatrix$node$goal, _distMatrix$node;\n        return (_distMatrix$node$goal = (_distMatrix$node = distMatrix[node]) === null || _distMatrix$node === void 0 ? void 0 : _distMatrix$node[goal]) !== null && _distMatrix$node$goal !== void 0 ? _distMatrix$node$goal : Infinity;\n      }));\n      return minDist < best.dist ? {\n        node,\n        dist: minDist\n      } : best;\n    }, {\n      node: null,\n      dist: Infinity\n    }).node;\n  },\n  /**\r\n   * @function findShortestPath\r\n   * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n   * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n   * @param {string} startRoom - Starting room identifier\r\n   * @param {string} endRoom - Ending room identifier\r\n   * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n   * @returns {number[]} Array of vertex indices forming the shortest path\r\n   */\n  findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\n    if (!(rooms !== null && rooms !== void 0 && rooms[startRoom]) || !(rooms !== null && rooms !== void 0 && rooms[endRoom]) || startRoom === endRoom) return [];\n    if (!(nextMatrix !== null && nextMatrix !== void 0 && nextMatrix.length) || !(distMatrix !== null && distMatrix !== void 0 && distMatrix.length)) return [];\n    const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\n    if (startNode === null) return [];\n    const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\n    if (endNode === null) return [];\n    return this.constructPath(nextMatrix, startNode, endNode);\n  }\n};","map":{"version":3,"names":["PathfindingModule","constructPath","nextMatrix","start","end","path","current","maxIterations","length","iterations","_nextMatrix$current","next","undefined","push","selectBestNode","nodes","goalNodes","distMatrix","reduce","best","node","minDist","Math","min","map","goal","_distMatrix$node$goal","_distMatrix$node","Infinity","dist","findShortestPath","startRoom","endRoom","rooms","startNode","endNode"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/PathfindingModule.js"],"sourcesContent":["/**\r\n * @module PathfindingModule\r\n * @description Handles pathfinding algorithms and route calculations between rooms\r\n */\r\n\r\nexport const PathfindingModule = {\r\n    /**\r\n     * @function constructPath\r\n     * @param {Array<Array<number>>} nextMatrix - Next vertex matrix for path reconstruction\r\n     * @param {number} start - Starting vertex index\r\n     * @param {number} end - Ending vertex index\r\n     * @returns {number[]} Array of vertex indices forming the path\r\n     */\r\n    constructPath(nextMatrix, start, end) {\r\n        // Add validation for matrix and indices\r\n        if (!nextMatrix?.[start] || !nextMatrix?.[end]) return [];\r\n        \r\n        const path = [start];\r\n        let current = start;\r\n        const maxIterations = nextMatrix.length; // Prevent infinite loops\r\n        let iterations = 0;\r\n        \r\n        while (current !== end && iterations < maxIterations) {\r\n            const next = nextMatrix[current]?.[end];\r\n            if (next === undefined || next === null) break;\r\n            path.push(next);\r\n            current = next;\r\n            iterations++;\r\n        }\r\n        \r\n        // Only return path if we actually reached the end\r\n        return path[path.length - 1] === end ? path : [];\r\n    },\r\n\r\n    /**\r\n     * @function selectBestNode\r\n     * @param {number[]} nodes - Array of candidate nodes\r\n     * @param {number[]} goalNodes - Array of possible goal nodes\r\n     * @param {Array<Array<number>>} distMatrix - Distance matrix between nodes\r\n     * @returns {number|null} Best node index or null if no valid node found\r\n     */\r\n    selectBestNode(nodes, goalNodes, distMatrix) {\r\n        if (!nodes?.length || !goalNodes?.length) return null;\r\n        return nodes.reduce((best, node) => {\r\n            const minDist = Math.min(...goalNodes.map(goal => \r\n                distMatrix[node]?.[goal] ?? Infinity\r\n            ));\r\n            return minDist < best.dist ? { node, dist: minDist } : best;\r\n        }, { node: null, dist: Infinity }).node;\r\n    },\r\n\r\n    /**\r\n     * @function findShortestPath\r\n     * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n     * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n     * @param {string} startRoom - Starting room identifier\r\n     * @param {string} endRoom - Ending room identifier\r\n     * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n     * @returns {number[]} Array of vertex indices forming the shortest path\r\n     */\r\n    findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\r\n        if (!rooms?.[startRoom] || !rooms?.[endRoom] || startRoom === endRoom) return [];\r\n        if (!nextMatrix?.length || !distMatrix?.length) return [];\r\n\r\n        const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\r\n        if (startNode === null) return [];\r\n\r\n        const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\r\n        if (endNode === null) return [];\r\n\r\n        return this.constructPath(nextMatrix, startNode, endNode);\r\n    }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}