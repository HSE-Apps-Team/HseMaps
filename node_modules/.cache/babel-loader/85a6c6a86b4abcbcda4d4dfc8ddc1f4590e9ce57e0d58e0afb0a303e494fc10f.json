{"ast":null,"code":"/**\r\n * @module ResourceManager\r\n * @description Centralized resource management for images, caching, and loading\r\n */\nimport { StateManager } from './StateManager.js';\nconst importAll = r => {\n  const images = {};\n  r.keys().forEach(key => {\n    images[key.replace('./', '')] = r(key);\n  });\n  return images;\n};\nexport const ResourceManager = {\n  // Centralized caches\n  imageCache: new Map(),\n  loadingPromises: new Map(),\n  streetViewImages: importAll(require.context('../elements/StreetImages', false, /\\.(png|jpe?g|svg)$/)),\n  DEFAULT_IMAGE: '/assets/no-streetview.jpg',\n  buffer: {\n    current: null,\n    next: null\n  },\n  /**\r\n   * Gets URL for a specific image\r\n   * @param {string} imageName - Image name to look up\r\n   * @returns {string} URL for the image or empty string if not found\r\n   */\n  getImageUrl(imageName) {\n    return this.streetViewImages[imageName] || '';\n  },\n  /**\r\n   * Preloads images for a path to ensure smooth navigation\r\n   * @param {Array<number>} path - The full navigation path\r\n   * @returns {Promise<string[]>} Array of image URLs that were preloaded\r\n   */\n  async preloadImagesForPath(path) {\n    if (!(path !== null && path !== void 0 && path.length)) return [];\n    const imageUrls = [];\n    for (let i = 0; i < path.length - 1; i++) {\n      const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\n      const imageUrl = await this.loadImage(imageKey);\n      imageUrls.push(imageUrl);\n    }\n    return imageUrls;\n  },\n  /**\r\n   * Loads a single image and caches it\r\n   * @param {string} imageKey - Key identifying the image to load\r\n   * @returns {Promise<string>} Promise resolving to the image URL\r\n   */\n  async loadImage(imageKey) {\n    if (this.imageCache.has(imageKey)) {\n      return this.imageCache.get(imageKey);\n    }\n    if (this.loadingPromises.has(imageKey)) {\n      return this.loadingPromises.get(imageKey);\n    }\n    const imageUrl = this.getImageUrl(imageKey);\n    if (!imageUrl) {\n      return this.DEFAULT_IMAGE;\n    }\n    const loadPromise = new Promise(resolve => {\n      const img = new Image();\n      img.onload = () => {\n        this.imageCache.set(imageKey, imageUrl);\n        this.loadingPromises.delete(imageKey);\n        resolve(imageUrl);\n      };\n      img.onerror = () => {\n        this.loadingPromises.delete(imageKey);\n        resolve(this.DEFAULT_IMAGE);\n      };\n      img.src = imageUrl;\n    });\n    this.loadingPromises.set(imageKey, loadPromise);\n    return loadPromise;\n  },\n  /**\r\n   * Prepares the next image in the buffer\r\n   * @param {string} imageKey - Key of the image to prepare\r\n   */\n  async prepareNextImage(imageKey) {\n    if (!imageKey) return;\n    try {\n      const imageUrl = await this.loadImage(imageKey);\n      this.buffer.next = imageUrl;\n    } catch (error) {\n      console.error('Failed to prepare next image:', error);\n      this.buffer.next = this.DEFAULT_IMAGE;\n    }\n  },\n  /**\r\n   * Swaps the current and next buffered images\r\n   * @returns {string} URL of the current image\r\n   */\n  swapBuffers() {\n    this.buffer.current = this.buffer.next || this.DEFAULT_IMAGE;\n    this.buffer.next = null;\n    return this.buffer.current;\n  },\n  /**\r\n   * Gets the appropriate image for the current path segment with double buffering\r\n   * @returns {string} URL of the image to display\r\n   */\n  getPathSegmentImage() {\n    const currentPathSegment = StateManager.get('currentPathSegment');\n    const path = StateManager.get('path');\n    if (!path || currentPathSegment === undefined || currentPathSegment < 0 || currentPathSegment >= path.length - 1) {\n      return this.DEFAULT_IMAGE;\n    }\n    const currentImageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\n    const nextImageKey = currentPathSegment < path.length - 2 ? `${path[currentPathSegment + 1]}-${path[currentPathSegment + 2]}.jpg` : null;\n\n    // Prepare next image in advance\n    if (nextImageKey) {\n      this.prepareNextImage(nextImageKey);\n    }\n    return this.swapBuffers();\n  },\n  /**\r\n   * Clears all cached resources\r\n   */\n  clearCache() {\n    this.imageCache.clear();\n    this.loadingPromises.clear();\n  }\n};","map":{"version":3,"names":["StateManager","importAll","r","images","keys","forEach","key","replace","ResourceManager","imageCache","Map","loadingPromises","streetViewImages","require","context","DEFAULT_IMAGE","buffer","current","next","getImageUrl","imageName","preloadImagesForPath","path","length","imageUrls","i","imageKey","imageUrl","loadImage","push","has","get","loadPromise","Promise","resolve","img","Image","onload","set","delete","onerror","src","prepareNextImage","error","console","swapBuffers","getPathSegmentImage","currentPathSegment","undefined","currentImageKey","nextImageKey","clearCache","clear"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/ResourceManager.js"],"sourcesContent":["/**\r\n * @module ResourceManager\r\n * @description Centralized resource management for images, caching, and loading\r\n */\r\nimport { StateManager } from './StateManager.js';\r\n\r\nconst importAll = (r) => {\r\n    const images = {};\r\n    r.keys().forEach((key) => {\r\n        images[key.replace('./', '')] = r(key);\r\n    });\r\n    return images;\r\n};\r\n\r\nexport const ResourceManager = {\r\n    // Centralized caches\r\n    imageCache: new Map(),\r\n    loadingPromises: new Map(),\r\n    streetViewImages: importAll(require.context('../elements/StreetImages', false, /\\.(png|jpe?g|svg)$/)),\r\n    DEFAULT_IMAGE: '/assets/no-streetview.jpg',\r\n    buffer: {\r\n        current: null,\r\n        next: null\r\n    },\r\n\r\n    /**\r\n     * Gets URL for a specific image\r\n     * @param {string} imageName - Image name to look up\r\n     * @returns {string} URL for the image or empty string if not found\r\n     */\r\n    getImageUrl(imageName) {\r\n        return this.streetViewImages[imageName] || '';\r\n    },\r\n\r\n    /**\r\n     * Preloads images for a path to ensure smooth navigation\r\n     * @param {Array<number>} path - The full navigation path\r\n     * @returns {Promise<string[]>} Array of image URLs that were preloaded\r\n     */\r\n    async preloadImagesForPath(path) {\r\n        if (!path?.length) return [];\r\n\r\n        const imageUrls = [];\r\n        for (let i = 0; i < path.length - 1; i++) {\r\n            const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\r\n            const imageUrl = await this.loadImage(imageKey);\r\n            imageUrls.push(imageUrl);\r\n        }\r\n\r\n        return imageUrls;\r\n    },\r\n\r\n    /**\r\n     * Loads a single image and caches it\r\n     * @param {string} imageKey - Key identifying the image to load\r\n     * @returns {Promise<string>} Promise resolving to the image URL\r\n     */\r\n    async loadImage(imageKey) {\r\n        if (this.imageCache.has(imageKey)) {\r\n            return this.imageCache.get(imageKey);\r\n        }\r\n        \r\n        if (this.loadingPromises.has(imageKey)) {\r\n            return this.loadingPromises.get(imageKey);\r\n        }\r\n        \r\n        const imageUrl = this.getImageUrl(imageKey);\r\n        if (!imageUrl) {\r\n            return this.DEFAULT_IMAGE;\r\n        }\r\n        \r\n        const loadPromise = new Promise(resolve => {\r\n            const img = new Image();\r\n            img.onload = () => {\r\n                this.imageCache.set(imageKey, imageUrl);\r\n                this.loadingPromises.delete(imageKey);\r\n                resolve(imageUrl);\r\n            };\r\n            img.onerror = () => {\r\n                this.loadingPromises.delete(imageKey);\r\n                resolve(this.DEFAULT_IMAGE);\r\n            };\r\n            img.src = imageUrl;\r\n        });\r\n        \r\n        this.loadingPromises.set(imageKey, loadPromise);\r\n        return loadPromise;\r\n    },\r\n    \r\n    /**\r\n     * Prepares the next image in the buffer\r\n     * @param {string} imageKey - Key of the image to prepare\r\n     */\r\n    async prepareNextImage(imageKey) {\r\n        if (!imageKey) return;\r\n\r\n        try {\r\n            const imageUrl = await this.loadImage(imageKey);\r\n            this.buffer.next = imageUrl;\r\n        } catch (error) {\r\n            console.error('Failed to prepare next image:', error);\r\n            this.buffer.next = this.DEFAULT_IMAGE;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Swaps the current and next buffered images\r\n     * @returns {string} URL of the current image\r\n     */\r\n    swapBuffers() {\r\n        this.buffer.current = this.buffer.next || this.DEFAULT_IMAGE;\r\n        this.buffer.next = null;\r\n        return this.buffer.current;\r\n    },\r\n\r\n    /**\r\n     * Gets the appropriate image for the current path segment with double buffering\r\n     * @returns {string} URL of the image to display\r\n     */\r\n    getPathSegmentImage() {\r\n        const currentPathSegment = StateManager.get('currentPathSegment');\r\n        const path = StateManager.get('path');\r\n        \r\n        if (!path || currentPathSegment === undefined || \r\n            currentPathSegment < 0 || currentPathSegment >= path.length - 1) {\r\n            return this.DEFAULT_IMAGE;\r\n        }\r\n        \r\n        const currentImageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\r\n        const nextImageKey = currentPathSegment < path.length - 2 ? \r\n            `${path[currentPathSegment + 1]}-${path[currentPathSegment + 2]}.jpg` : null;\r\n\r\n        // Prepare next image in advance\r\n        if (nextImageKey) {\r\n            this.prepareNextImage(nextImageKey);\r\n        }\r\n\r\n        return this.swapBuffers();\r\n    },\r\n\r\n    /**\r\n     * Clears all cached resources\r\n     */\r\n    clearCache() {\r\n        this.imageCache.clear();\r\n        this.loadingPromises.clear();\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}