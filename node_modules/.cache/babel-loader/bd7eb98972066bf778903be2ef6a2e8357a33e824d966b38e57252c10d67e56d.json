{"ast":null,"code":"import { StateManager } from './StateManager.js';\nimport { ImageModule } from './ImageModule.js';\n\n/**\r\n * @module StreetViewModule\r\n * @description Manages street view image retrieval and display for path segments,\r\n * including fallback handling for missing images and error states.\r\n */\nexport const StreetViewModule = {\n  /** @constant {string} DEFAULT_IMAGE - Path to the default fallback image */\n  DEFAULT_IMAGE: '/assets/no-streetview.jpg',\n  imageCache: new Map(),\n  MAX_CACHE_SIZE: 50,\n  // Maximum number of images to keep in cache\n  preloadAbortController: null,\n  // For cancelling previous preloads\n\n  /**\r\n   * Preloads images for the given path.\r\n   * @param {Array} path - The path segments to preload images for\r\n   */\n  async preloadImagesForPath(path) {\n    if (!(path !== null && path !== void 0 && path.length)) return;\n\n    // Cancel any ongoing preloading\n    if (this.preloadAbortController) {\n      this.preloadAbortController.abort();\n    }\n    this.preloadAbortController = new AbortController();\n    const signal = this.preloadAbortController.signal;\n    const loadPromises = [];\n    for (let i = 0; i < path.length - 1; i++) {\n      const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\n      if (!this.imageCache.has(imageKey)) {\n        loadPromises.push((async () => {\n          try {\n            if (signal.aborted) return;\n            const imageUrl = ImageModule.getImageUrl(imageKey);\n            if (imageUrl) {\n              const img = new Image();\n              img.src = imageUrl;\n              await img.decode(); // Wait for image to load\n\n              if (signal.aborted) return;\n\n              // Manage cache size\n              if (this.imageCache.size >= this.MAX_CACHE_SIZE) {\n                // Remove the oldest entry\n                const firstKey = this.imageCache.keys().next().value;\n                this.imageCache.delete(firstKey);\n              }\n              this.imageCache.set(imageKey, imageUrl);\n            }\n          } catch (error) {\n            if (!signal.aborted) {\n              console.warn(`Failed to preload image: ${imageKey}`);\n            }\n          }\n        })());\n      }\n    }\n    try {\n      // Load all images in parallel instead of sequentially\n      await Promise.all(loadPromises);\n    } catch (error) {\n      if (error.name !== 'AbortError') {\n        console.error('Error during image preloading:', error);\n      }\n    } finally {\n      var _this$preloadAbortCon;\n      if (((_this$preloadAbortCon = this.preloadAbortController) === null || _this$preloadAbortCon === void 0 ? void 0 : _this$preloadAbortCon.signal) === signal) {\n        this.preloadAbortController = null;\n      }\n    }\n  },\n  /**\r\n   * Retrieves the appropriate street view image for the current path segment.\r\n   * @returns {string} URL of the street view image or default image if none available\r\n   * @throws {Error} When image retrieval fails\r\n   */\n  getImage() {\n    const currentPathSegment = StateManager.get('currentPathSegment');\n    const path = StateManager.get('path');\n    if (!path || currentPathSegment === undefined) {\n      return ImageModule.getImageUrl('no-streetview.jpg');\n    }\n    const imageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\n    // Check cache first\n    if (this.imageCache.has(imageKey)) {\n      return this.imageCache.get(imageKey);\n    }\n    const imageUrl = ImageModule.getImageUrl(imageKey);\n    if (imageUrl) {\n      this.imageCache.set(imageKey, imageUrl);\n      return imageUrl;\n    }\n    return ImageModule.getImageUrl('no-streetview.jpg');\n  },\n  /**\r\n   * Clears the image cache.\r\n   */\n  clearCache() {\n    this.imageCache.clear();\n  }\n};","map":{"version":3,"names":["StateManager","ImageModule","StreetViewModule","DEFAULT_IMAGE","imageCache","Map","MAX_CACHE_SIZE","preloadAbortController","preloadImagesForPath","path","length","abort","AbortController","signal","loadPromises","i","imageKey","has","push","aborted","imageUrl","getImageUrl","img","Image","src","decode","size","firstKey","keys","next","value","delete","set","error","console","warn","Promise","all","name","_this$preloadAbortCon","getImage","currentPathSegment","get","undefined","clearCache","clear"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/StreetViewModule.js"],"sourcesContent":["import { StateManager } from './StateManager.js';\r\nimport { ImageModule } from './ImageModule.js';\r\n\r\n/**\r\n * @module StreetViewModule\r\n * @description Manages street view image retrieval and display for path segments,\r\n * including fallback handling for missing images and error states.\r\n */\r\nexport const StreetViewModule = {\r\n    /** @constant {string} DEFAULT_IMAGE - Path to the default fallback image */\r\n    DEFAULT_IMAGE: '/assets/no-streetview.jpg',\r\n    imageCache: new Map(),\r\n    MAX_CACHE_SIZE: 50, // Maximum number of images to keep in cache\r\n    preloadAbortController: null, // For cancelling previous preloads\r\n\r\n    /**\r\n     * Preloads images for the given path.\r\n     * @param {Array} path - The path segments to preload images for\r\n     */\r\n    async preloadImagesForPath(path) {\r\n        if (!path?.length) return;\r\n        \r\n        // Cancel any ongoing preloading\r\n        if (this.preloadAbortController) {\r\n            this.preloadAbortController.abort();\r\n        }\r\n        \r\n        this.preloadAbortController = new AbortController();\r\n        const signal = this.preloadAbortController.signal;\r\n        \r\n        const loadPromises = [];\r\n        \r\n        for (let i = 0; i < path.length - 1; i++) {\r\n            const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\r\n            if (!this.imageCache.has(imageKey)) {\r\n                loadPromises.push((async () => {\r\n                    try {\r\n                        if (signal.aborted) return;\r\n                        \r\n                        const imageUrl = ImageModule.getImageUrl(imageKey);\r\n                        if (imageUrl) {\r\n                            const img = new Image();\r\n                            img.src = imageUrl;\r\n                            await img.decode(); // Wait for image to load\r\n                            \r\n                            if (signal.aborted) return;\r\n                            \r\n                            // Manage cache size\r\n                            if (this.imageCache.size >= this.MAX_CACHE_SIZE) {\r\n                                // Remove the oldest entry\r\n                                const firstKey = this.imageCache.keys().next().value;\r\n                                this.imageCache.delete(firstKey);\r\n                            }\r\n                            \r\n                            this.imageCache.set(imageKey, imageUrl);\r\n                        }\r\n                    } catch (error) {\r\n                        if (!signal.aborted) {\r\n                            console.warn(`Failed to preload image: ${imageKey}`);\r\n                        }\r\n                    }\r\n                })());\r\n            }\r\n        }\r\n        \r\n        try {\r\n            // Load all images in parallel instead of sequentially\r\n            await Promise.all(loadPromises);\r\n        } catch (error) {\r\n            if (error.name !== 'AbortError') {\r\n                console.error('Error during image preloading:', error);\r\n            }\r\n        } finally {\r\n            if (this.preloadAbortController?.signal === signal) {\r\n                this.preloadAbortController = null;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves the appropriate street view image for the current path segment.\r\n     * @returns {string} URL of the street view image or default image if none available\r\n     * @throws {Error} When image retrieval fails\r\n     */\r\n    getImage() {\r\n        const currentPathSegment = StateManager.get('currentPathSegment');\r\n        const path = StateManager.get('path');\r\n\r\n        if (!path || currentPathSegment === undefined) {\r\n            return ImageModule.getImageUrl('no-streetview.jpg');\r\n        }\r\n\r\n        const imageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\r\n        // Check cache first\r\n        if (this.imageCache.has(imageKey)) {\r\n            return this.imageCache.get(imageKey);\r\n        }\r\n        \r\n        const imageUrl = ImageModule.getImageUrl(imageKey);\r\n        if (imageUrl) {\r\n            this.imageCache.set(imageKey, imageUrl);\r\n            return imageUrl;\r\n        }\r\n        \r\n        return ImageModule.getImageUrl('no-streetview.jpg');\r\n    },\r\n\r\n    /**\r\n     * Clears the image cache.\r\n     */\r\n    clearCache() {\r\n        this.imageCache.clear();\r\n    }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}