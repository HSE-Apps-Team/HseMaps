{"ast":null,"code":"/**\r\n * PathfindingModule - Handles path construction and node selection for navigation\r\n * Provides methods for finding optimal paths between rooms and reconstructing paths\r\n * from precomputed matrices\r\n * \r\n * @module PathfindingModule\r\n */\nexport const PathfindingModule = {\n  /**\r\n   * Constructs a path between two vertices using a next-vertex matrix\r\n   * @param {number[][]} nextMatrix - Matrix containing next vertex in shortest path\r\n   * @param {number} u - Starting vertex index\r\n   * @param {number} v - Ending vertex index\r\n   * @returns {number[]} Array of vertex indices forming the path\r\n   * \r\n   * @example\r\n   * // Given nextMatrix:\r\n   * // [[0, 1, 2],\r\n   * //  [1, 1, 2],\r\n   * //  [2, 2, 2]]\r\n   * constructPath(nextMatrix, 0, 2)\r\n   * // Returns: [0, 1, 2]\r\n   * \r\n   * @example Edge case - no path exists\r\n   * constructPath(nextMatrix, 0, 3)\r\n   * // Returns: []\r\n   */\n  constructPath(nextMatrix, u, v) {\n    var _nextMatrix$u;\n    if (!((_nextMatrix$u = nextMatrix[u]) !== null && _nextMatrix$u !== void 0 && _nextMatrix$u[v])) return [];\n    const path = [u];\n    while (path[path.length - 1] !== v) {\n      const next = nextMatrix[path[path.length - 1]][v];\n      if (!next && next !== 0) break;\n      path.push(next);\n    }\n    return path;\n  },\n  /**\r\n   * Selects the best node from a set based on minimum distance to goal nodes\r\n   * @param {number[]} nodes - Array of candidate node indices\r\n   * @param {number[]} goalNodes - Array of target node indices\r\n   * @param {number[][]} distMatrix - Matrix of distances between nodes\r\n   * @returns {number|null} Index of best node or null if no valid node found\r\n   * \r\n   * @example\r\n   * // Given distMatrix:\r\n   * // [[0, 5, Infinity],\r\n   * //  [5, 0, 3],\r\n   * //  [Infinity, 3, 0]]\r\n   * selectBestNode([0, 1], [2], distMatrix)\r\n   * // Returns: 1 (node 1 has shortest path to goal node 2)\r\n   * \r\n   * @example No valid path\r\n   * selectBestNode([0], [2], distMatrix)\r\n   * // Returns: null (no path from node 0 to goal node 2)\r\n   */\n  selectBestNode(nodes, goalNodes, distMatrix) {\n    return nodes.reduce((best, node) => {\n      const minDist = Math.min(...goalNodes.map(goal => {\n        var _distMatrix$node$goal, _distMatrix$node;\n        return (_distMatrix$node$goal = (_distMatrix$node = distMatrix[node]) === null || _distMatrix$node === void 0 ? void 0 : _distMatrix$node[goal]) !== null && _distMatrix$node$goal !== void 0 ? _distMatrix$node$goal : Infinity;\n      }));\n      return minDist < best.dist ? {\n        node,\n        dist: minDist\n      } : best;\n    }, {\n      node: null,\n      dist: Infinity\n    }).node;\n  },\n  /**\r\n   * Finds shortest path between two rooms using precomputed matrices\r\n   * @param {number[][]} nextMatrix - Matrix containing next vertex in shortest path\r\n   * @param {number[][]} distMatrix - Matrix of distances between nodes\r\n   * @param {string} startRoom - Starting room identifier\r\n   * @param {string} endRoom - Destination room identifier\r\n   * @param {Object<string, number[]>} rooms - Map of room IDs to vertex indices\r\n   * @returns {number[]} Array of vertex indices forming the shortest path\r\n   * \r\n   * @example\r\n   * // Given room mapping:\r\n   * // rooms = { \"ROOM101\": [0, 1], \"ROOM102\": [2] }\r\n   * minPathBtwRooms(nextMatrix, distMatrix, \"ROOM101\", \"ROOM102\", rooms)\r\n   * // Returns: [1, 2] (shortest path from ROOM101 to ROOM102)\r\n   * \r\n   * @example No valid path\r\n   * minPathBtwRooms(nextMatrix, distMatrix, \"ROOM101\", \"ROOM999\", rooms)\r\n   * // Returns: [] (no path exists or invalid room)\r\n   */\n  minPathBtwRooms(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\n    const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\n    const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\n    return this.constructPath(nextMatrix, startNode, endNode);\n  }\n};","map":{"version":3,"names":["PathfindingModule","constructPath","nextMatrix","u","v","_nextMatrix$u","path","length","next","push","selectBestNode","nodes","goalNodes","distMatrix","reduce","best","node","minDist","Math","min","map","goal","_distMatrix$node$goal","_distMatrix$node","Infinity","dist","minPathBtwRooms","startRoom","endRoom","rooms","startNode","endNode"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/PathfindingModule.js"],"sourcesContent":["/**\r\n * PathfindingModule - Handles path construction and node selection for navigation\r\n * Provides methods for finding optimal paths between rooms and reconstructing paths\r\n * from precomputed matrices\r\n * \r\n * @module PathfindingModule\r\n */\r\nexport const PathfindingModule = {\r\n    /**\r\n     * Constructs a path between two vertices using a next-vertex matrix\r\n     * @param {number[][]} nextMatrix - Matrix containing next vertex in shortest path\r\n     * @param {number} u - Starting vertex index\r\n     * @param {number} v - Ending vertex index\r\n     * @returns {number[]} Array of vertex indices forming the path\r\n     * \r\n     * @example\r\n     * // Given nextMatrix:\r\n     * // [[0, 1, 2],\r\n     * //  [1, 1, 2],\r\n     * //  [2, 2, 2]]\r\n     * constructPath(nextMatrix, 0, 2)\r\n     * // Returns: [0, 1, 2]\r\n     * \r\n     * @example Edge case - no path exists\r\n     * constructPath(nextMatrix, 0, 3)\r\n     * // Returns: []\r\n     */\r\n    constructPath(nextMatrix, u, v) {\r\n        if (!nextMatrix[u]?.[v]) return [];\r\n        const path = [u];\r\n        while (path[path.length - 1] !== v) {\r\n            const next = nextMatrix[path[path.length - 1]][v];\r\n            if (!next && next !== 0) break;\r\n            path.push(next);\r\n        }\r\n        return path;\r\n    },\r\n\r\n    /**\r\n     * Selects the best node from a set based on minimum distance to goal nodes\r\n     * @param {number[]} nodes - Array of candidate node indices\r\n     * @param {number[]} goalNodes - Array of target node indices\r\n     * @param {number[][]} distMatrix - Matrix of distances between nodes\r\n     * @returns {number|null} Index of best node or null if no valid node found\r\n     * \r\n     * @example\r\n     * // Given distMatrix:\r\n     * // [[0, 5, Infinity],\r\n     * //  [5, 0, 3],\r\n     * //  [Infinity, 3, 0]]\r\n     * selectBestNode([0, 1], [2], distMatrix)\r\n     * // Returns: 1 (node 1 has shortest path to goal node 2)\r\n     * \r\n     * @example No valid path\r\n     * selectBestNode([0], [2], distMatrix)\r\n     * // Returns: null (no path from node 0 to goal node 2)\r\n     */\r\n    selectBestNode(nodes, goalNodes, distMatrix) {\r\n        return nodes.reduce((best, node) => {\r\n            const minDist = Math.min(...goalNodes.map(goal => \r\n                distMatrix[node]?.[goal] ?? Infinity\r\n            ));\r\n            return minDist < best.dist ? { node, dist: minDist } : best;\r\n        }, { node: null, dist: Infinity }).node;\r\n    },\r\n\r\n    /**\r\n     * Finds shortest path between two rooms using precomputed matrices\r\n     * @param {number[][]} nextMatrix - Matrix containing next vertex in shortest path\r\n     * @param {number[][]} distMatrix - Matrix of distances between nodes\r\n     * @param {string} startRoom - Starting room identifier\r\n     * @param {string} endRoom - Destination room identifier\r\n     * @param {Object<string, number[]>} rooms - Map of room IDs to vertex indices\r\n     * @returns {number[]} Array of vertex indices forming the shortest path\r\n     * \r\n     * @example\r\n     * // Given room mapping:\r\n     * // rooms = { \"ROOM101\": [0, 1], \"ROOM102\": [2] }\r\n     * minPathBtwRooms(nextMatrix, distMatrix, \"ROOM101\", \"ROOM102\", rooms)\r\n     * // Returns: [1, 2] (shortest path from ROOM101 to ROOM102)\r\n     * \r\n     * @example No valid path\r\n     * minPathBtwRooms(nextMatrix, distMatrix, \"ROOM101\", \"ROOM999\", rooms)\r\n     * // Returns: [] (no path exists or invalid room)\r\n     */\r\n    minPathBtwRooms(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\r\n        const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\r\n        const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\r\n        return this.constructPath(nextMatrix, startNode, endNode);\r\n    }\r\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,iBAAiB,GAAG;EAC7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAaA,CAACC,UAAU,EAAEC,CAAC,EAAEC,CAAC,EAAE;IAAA,IAAAC,aAAA;IAC5B,IAAI,GAAAA,aAAA,GAACH,UAAU,CAACC,CAAC,CAAC,cAAAE,aAAA,eAAbA,aAAA,CAAgBD,CAAC,CAAC,GAAE,OAAO,EAAE;IAClC,MAAME,IAAI,GAAG,CAACH,CAAC,CAAC;IAChB,OAAOG,IAAI,CAACA,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC,KAAKH,CAAC,EAAE;MAChC,MAAMI,IAAI,GAAGN,UAAU,CAACI,IAAI,CAACA,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC,CAAC,CAACH,CAAC,CAAC;MACjD,IAAI,CAACI,IAAI,IAAIA,IAAI,KAAK,CAAC,EAAE;MACzBF,IAAI,CAACG,IAAI,CAACD,IAAI,CAAC;IACnB;IACA,OAAOF,IAAI;EACf,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,cAAcA,CAACC,KAAK,EAAEC,SAAS,EAAEC,UAAU,EAAE;IACzC,OAAOF,KAAK,CAACG,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAK;MAChC,MAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAGP,SAAS,CAACQ,GAAG,CAACC,IAAI;QAAA,IAAAC,qBAAA,EAAAC,gBAAA;QAAA,QAAAD,qBAAA,IAAAC,gBAAA,GAC1CV,UAAU,CAACG,IAAI,CAAC,cAAAO,gBAAA,uBAAhBA,gBAAA,CAAmBF,IAAI,CAAC,cAAAC,qBAAA,cAAAA,qBAAA,GAAIE,QAAQ;MAAA,CACxC,CAAC,CAAC;MACF,OAAOP,OAAO,GAAGF,IAAI,CAACU,IAAI,GAAG;QAAET,IAAI;QAAES,IAAI,EAAER;MAAQ,CAAC,GAAGF,IAAI;IAC/D,CAAC,EAAE;MAAEC,IAAI,EAAE,IAAI;MAAES,IAAI,EAAED;IAAS,CAAC,CAAC,CAACR,IAAI;EAC3C,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIU,eAAeA,CAACxB,UAAU,EAAEW,UAAU,EAAEc,SAAS,EAAEC,OAAO,EAAEC,KAAK,EAAE;IAC/D,MAAMC,SAAS,GAAG,IAAI,CAACpB,cAAc,CAACmB,KAAK,CAACF,SAAS,CAAC,EAAEE,KAAK,CAACD,OAAO,CAAC,EAAEf,UAAU,CAAC;IACnF,MAAMkB,OAAO,GAAG,IAAI,CAACrB,cAAc,CAACmB,KAAK,CAACD,OAAO,CAAC,EAAE,CAACE,SAAS,CAAC,EAAEjB,UAAU,CAAC;IAC5E,OAAO,IAAI,CAACZ,aAAa,CAACC,UAAU,EAAE4B,SAAS,EAAEC,OAAO,CAAC;EAC7D;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}