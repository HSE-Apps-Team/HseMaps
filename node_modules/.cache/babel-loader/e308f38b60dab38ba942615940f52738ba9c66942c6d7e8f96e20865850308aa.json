{"ast":null,"code":"/**\r\n * @module PathfindingModule\r\n * @description Implements path finding algorithms with performance optimizations\r\n */\n\nexport class PathfindingModule {\n  /**\r\n   * Reconstructs path from precomputed next vertex matrix\r\n   * @param {number[][]} nextMatrix - Precomputed next vertex lookup table\r\n   * @param {number} start - Starting vertex index\r\n   * @param {number} end - Target vertex index\r\n   * @returns {number[]} Vertex indices forming the path\r\n   */\n  static constructPath(nextMatrix, start, end) {\n    if (!this.validateMatrix(nextMatrix, start, end)) return [];\n    const path = [start];\n    let current = start;\n    while (current !== end) {\n      var _nextMatrix$current;\n      const next = (_nextMatrix$current = nextMatrix[current]) === null || _nextMatrix$current === void 0 ? void 0 : _nextMatrix$current[end];\n      if (next == null) break;\n      path.push(next);\n      current = next;\n    }\n    return path;\n  }\n\n  /**\r\n   * Selects optimal node based on distance heuristic\r\n   * @param {number[]} nodes - Candidate nodes\r\n   * @param {number[]} goals - Target nodes\r\n   * @param {number[][]} distMatrix - Distance matrix\r\n   */\n  static selectBestNode(nodes, goals, distMatrix) {\n    if (!(nodes !== null && nodes !== void 0 && nodes.length) || !(goals !== null && goals !== void 0 && goals.length)) return null;\n    return nodes.reduce((best, node) => {\n      const minDist = Math.min(...goals.map(goal => {\n        var _distMatrix$node$goal, _distMatrix$node;\n        return (_distMatrix$node$goal = (_distMatrix$node = distMatrix[node]) === null || _distMatrix$node === void 0 ? void 0 : _distMatrix$node[goal]) !== null && _distMatrix$node$goal !== void 0 ? _distMatrix$node$goal : Infinity;\n      }));\n      return minDist < best.dist ? {\n        node,\n        dist: minDist\n      } : best;\n    }, {\n      node: null,\n      dist: Infinity\n    }).node;\n  }\n\n  /**\r\n   * @function findShortestPath\r\n   * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n   * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n   * @param {string} startRoom - Starting room identifier\r\n   * @param {string} endRoom - Ending room identifier\r\n   * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n   * @returns {number[]} Array of vertex indices forming the shortest path\r\n   */\n  findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\n    if (!rooms[startRoom] || !rooms[endRoom]) {\n      return [];\n    }\n    if (startRoom === endRoom) {\n      return [];\n    }\n    const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\n    if (!startNode && startNode !== 0) {\n      return [];\n    }\n    const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\n    if (!endNode && endNode !== 0) {\n      return [];\n    }\n    return this.constructPath(nextMatrix, startNode, endNode);\n  }\n\n  /**\r\n   * Validates path finding input parameters\r\n   * @private\r\n   */\n  static validateMatrix(matrix, start, end) {\n    var _matrix$start;\n    return (matrix === null || matrix === void 0 ? void 0 : (_matrix$start = matrix[start]) === null || _matrix$start === void 0 ? void 0 : _matrix$start[end]) != null;\n  }\n}","map":{"version":3,"names":["PathfindingModule","constructPath","nextMatrix","start","end","validateMatrix","path","current","_nextMatrix$current","next","push","selectBestNode","nodes","goals","distMatrix","length","reduce","best","node","minDist","Math","min","map","goal","_distMatrix$node$goal","_distMatrix$node","Infinity","dist","findShortestPath","startRoom","endRoom","rooms","startNode","endNode","matrix","_matrix$start"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/PathfindingModule.js"],"sourcesContent":["/**\r\n * @module PathfindingModule\r\n * @description Implements path finding algorithms with performance optimizations\r\n */\r\n\r\nexport class PathfindingModule {\r\n    /**\r\n     * Reconstructs path from precomputed next vertex matrix\r\n     * @param {number[][]} nextMatrix - Precomputed next vertex lookup table\r\n     * @param {number} start - Starting vertex index\r\n     * @param {number} end - Target vertex index\r\n     * @returns {number[]} Vertex indices forming the path\r\n     */\r\n    static constructPath(nextMatrix, start, end) {\r\n        if (!this.validateMatrix(nextMatrix, start, end)) return [];\r\n        \r\n        const path = [start];\r\n        let current = start;\r\n        \r\n        while (current !== end) {\r\n            const next = nextMatrix[current]?.[end];\r\n            if (next == null) break;\r\n            path.push(next);\r\n            current = next;\r\n        }\r\n        \r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Selects optimal node based on distance heuristic\r\n     * @param {number[]} nodes - Candidate nodes\r\n     * @param {number[]} goals - Target nodes\r\n     * @param {number[][]} distMatrix - Distance matrix\r\n     */\r\n    static selectBestNode(nodes, goals, distMatrix) {\r\n        if (!nodes?.length || !goals?.length) return null;\r\n        \r\n        return nodes.reduce((best, node) => {\r\n            const minDist = Math.min(...goals.map(goal => \r\n                distMatrix[node]?.[goal] ?? Infinity\r\n            ));\r\n            return minDist < best.dist ? { node, dist: minDist } : best;\r\n        }, { node: null, dist: Infinity }).node;\r\n    }\r\n\r\n    /**\r\n     * @function findShortestPath\r\n     * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n     * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n     * @param {string} startRoom - Starting room identifier\r\n     * @param {string} endRoom - Ending room identifier\r\n     * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n     * @returns {number[]} Array of vertex indices forming the shortest path\r\n     */\r\n    findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\r\n        if (!rooms[startRoom] || !rooms[endRoom]) {\r\n            return [];\r\n        }\r\n\r\n        if (startRoom === endRoom) {\r\n            return [];\r\n        }\r\n\r\n        const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\r\n        if (!startNode && startNode !== 0) {\r\n            return [];\r\n        }\r\n\r\n        const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\r\n        if (!endNode && endNode !== 0) {\r\n            return [];\r\n        }\r\n\r\n        return this.constructPath(nextMatrix, startNode, endNode);\r\n    }\r\n\r\n    /**\r\n     * Validates path finding input parameters\r\n     * @private\r\n     */\r\n    static validateMatrix(matrix, start, end) {\r\n        return matrix?.[start]?.[end] != null;\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}