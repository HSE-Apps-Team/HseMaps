{"ast":null,"code":"/**\r\n * PathTransitionHandler - Manages transitions between floor levels\r\n * Handles state changes during path traversal and prevents recursive updates\r\n * \r\n * @module PathTransitionHandler\r\n */\nimport { Config } from '../config/config.js';\nimport { StateManager } from './StateManager.js';\nimport { DataModule } from './DataModule.js';\nexport const PathTransitionHandler = {\n  /** Flag to prevent recursive transition handling */\n  isTransitioning: false,\n  /**\r\n   * Handles state transitions during path traversal\r\n   * Manages transitions between floors and triggers appropriate callbacks\r\n   * \r\n   * @param {SVGGeometryElement} path - SVG path element being traversed\r\n   * @param {number} sliderValue - Current position along the path (0 to pathLength)\r\n   * @param {number} totalDistance - Total path distance including both floors\r\n   * @returns {boolean} True if transition occurred, false otherwise\r\n   * \r\n   * @example First floor to second floor\r\n   * // Given:\r\n   * path.getTotalLength() = 100\r\n   * sliderValue = 100          // At end of first floor\r\n   * totalDistance = 200\r\n   * StateManager.get('firstPathRendered') = true\r\n   * \r\n   * handleTransition(path, 100, 200)\r\n   * // Results in:\r\n   * // - firstPathRendered = false\r\n   * // - secondPathRendered = true\r\n   * // - onPathEnd() called\r\n   * // Returns: true\r\n   * \r\n   * @example Second floor to first floor\r\n   * // Given:\r\n   * path.getTotalLength() = 100\r\n   * sliderValue = 0           // At start of second floor\r\n   * totalDistance = 200\r\n   * StateManager.get('secondPathRendered') = true\r\n   * \r\n   * handleTransition(path, 0, 200)\r\n   * // Results in:\r\n   * // - firstPathRendered = true\r\n   * // - secondPathRendered = false\r\n   * // - onPathStart() called\r\n   * // Returns: true\r\n   * \r\n   * @example No transition needed\r\n   * // Given:\r\n   * sliderValue = 50         // Middle of current floor\r\n   * \r\n   * handleTransition(path, 50, 200)\r\n   * // Returns: false (no state change)\r\n   */\n  handleTransition(path, sliderValue, totalDistance) {\n    // Guard against recursive calls during state updates\n    if (this.isTransitioning) return false;\n    try {\n      this.isTransitioning = true;\n      const currentSegment = StateManager.get('currentPathSegment');\n      const fullPath = StateManager.get('path');\n      const distMatrix = DataModule.get().distMatrix;\n\n      // Check transition using stair distance\n      const isStairTransition = currentSegment < fullPath.length - 1 && distMatrix[fullPath[currentSegment]][fullPath[currentSegment + 1]] >= Config.THRESHOLD.STAIR_DISTANCE;\n      if (isStairTransition && StateManager.get('firstPathRendered')) {\n        StateManager.set('firstPathRendered', false);\n        StateManager.set('secondPathRendered', true);\n        const onPathEnd = StateManager.get('onPathEnd');\n        if (onPathEnd) onPathEnd();\n        return true;\n      }\n\n      // Check for transition back using stair distance\n      const isPreviousStair = currentSegment > 0 && distMatrix[fullPath[currentSegment - 1]][fullPath[currentSegment]] >= Config.THRESHOLD.STAIR_DISTANCE;\n      if (isPreviousStair && StateManager.get('secondPathRendered')) {\n        StateManager.set('firstPathRendered', true);\n        StateManager.set('secondPathRendered', false);\n        const onPathStart = StateManager.get('onPathStart');\n        if (onPathStart) onPathStart();\n        return true;\n      }\n      return false;\n    } finally {\n      this.isTransitioning = false;\n    }\n  }\n};","map":{"version":3,"names":["Config","StateManager","DataModule","PathTransitionHandler","isTransitioning","handleTransition","path","sliderValue","totalDistance","currentSegment","get","fullPath","distMatrix","isStairTransition","length","THRESHOLD","STAIR_DISTANCE","set","onPathEnd","isPreviousStair","onPathStart"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/PathTransitionHandler.js"],"sourcesContent":["/**\r\n * PathTransitionHandler - Manages transitions between floor levels\r\n * Handles state changes during path traversal and prevents recursive updates\r\n * \r\n * @module PathTransitionHandler\r\n */\r\nimport { Config } from '../config/config.js';\r\nimport { StateManager } from './StateManager.js';\r\nimport { DataModule } from './DataModule.js';\r\n\r\nexport const PathTransitionHandler = {\r\n    /** Flag to prevent recursive transition handling */\r\n    isTransitioning: false,\r\n\r\n    /**\r\n     * Handles state transitions during path traversal\r\n     * Manages transitions between floors and triggers appropriate callbacks\r\n     * \r\n     * @param {SVGGeometryElement} path - SVG path element being traversed\r\n     * @param {number} sliderValue - Current position along the path (0 to pathLength)\r\n     * @param {number} totalDistance - Total path distance including both floors\r\n     * @returns {boolean} True if transition occurred, false otherwise\r\n     * \r\n     * @example First floor to second floor\r\n     * // Given:\r\n     * path.getTotalLength() = 100\r\n     * sliderValue = 100          // At end of first floor\r\n     * totalDistance = 200\r\n     * StateManager.get('firstPathRendered') = true\r\n     * \r\n     * handleTransition(path, 100, 200)\r\n     * // Results in:\r\n     * // - firstPathRendered = false\r\n     * // - secondPathRendered = true\r\n     * // - onPathEnd() called\r\n     * // Returns: true\r\n     * \r\n     * @example Second floor to first floor\r\n     * // Given:\r\n     * path.getTotalLength() = 100\r\n     * sliderValue = 0           // At start of second floor\r\n     * totalDistance = 200\r\n     * StateManager.get('secondPathRendered') = true\r\n     * \r\n     * handleTransition(path, 0, 200)\r\n     * // Results in:\r\n     * // - firstPathRendered = true\r\n     * // - secondPathRendered = false\r\n     * // - onPathStart() called\r\n     * // Returns: true\r\n     * \r\n     * @example No transition needed\r\n     * // Given:\r\n     * sliderValue = 50         // Middle of current floor\r\n     * \r\n     * handleTransition(path, 50, 200)\r\n     * // Returns: false (no state change)\r\n     */\r\n    handleTransition(path, sliderValue, totalDistance) {\r\n        // Guard against recursive calls during state updates\r\n        if (this.isTransitioning) return false;\r\n        \r\n        try {\r\n            this.isTransitioning = true;\r\n            const currentSegment = StateManager.get('currentPathSegment');\r\n            const fullPath = StateManager.get('path');\r\n            const distMatrix = DataModule.get().distMatrix;\r\n\r\n            // Check transition using stair distance\r\n            const isStairTransition = currentSegment < fullPath.length - 1 && \r\n                distMatrix[fullPath[currentSegment]][fullPath[currentSegment + 1]] >= Config.THRESHOLD.STAIR_DISTANCE;\r\n            \r\n            if (isStairTransition && StateManager.get('firstPathRendered')) {\r\n                StateManager.set('firstPathRendered', false);\r\n                StateManager.set('secondPathRendered', true);\r\n                const onPathEnd = StateManager.get('onPathEnd');\r\n                if (onPathEnd) onPathEnd();\r\n                return true;\r\n            }\r\n            \r\n            // Check for transition back using stair distance\r\n            const isPreviousStair = currentSegment > 0 && \r\n                distMatrix[fullPath[currentSegment - 1]][fullPath[currentSegment]] >= Config.THRESHOLD.STAIR_DISTANCE;\r\n            \r\n            if (isPreviousStair && StateManager.get('secondPathRendered')) {\r\n                StateManager.set('firstPathRendered', true);\r\n                StateManager.set('secondPathRendered', false);\r\n                const onPathStart = StateManager.get('onPathStart');\r\n                if (onPathStart) onPathStart();\r\n                return true;\r\n            }\r\n            \r\n            return false;\r\n        } finally {\r\n            this.isTransitioning = false;\r\n        }\r\n    }\r\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,qBAAqB;AAC5C,SAASC,YAAY,QAAQ,mBAAmB;AAChD,SAASC,UAAU,QAAQ,iBAAiB;AAE5C,OAAO,MAAMC,qBAAqB,GAAG;EACjC;EACAC,eAAe,EAAE,KAAK;EAEtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,gBAAgBA,CAACC,IAAI,EAAEC,WAAW,EAAEC,aAAa,EAAE;IAC/C;IACA,IAAI,IAAI,CAACJ,eAAe,EAAE,OAAO,KAAK;IAEtC,IAAI;MACA,IAAI,CAACA,eAAe,GAAG,IAAI;MAC3B,MAAMK,cAAc,GAAGR,YAAY,CAACS,GAAG,CAAC,oBAAoB,CAAC;MAC7D,MAAMC,QAAQ,GAAGV,YAAY,CAACS,GAAG,CAAC,MAAM,CAAC;MACzC,MAAME,UAAU,GAAGV,UAAU,CAACQ,GAAG,CAAC,CAAC,CAACE,UAAU;;MAE9C;MACA,MAAMC,iBAAiB,GAAGJ,cAAc,GAAGE,QAAQ,CAACG,MAAM,GAAG,CAAC,IAC1DF,UAAU,CAACD,QAAQ,CAACF,cAAc,CAAC,CAAC,CAACE,QAAQ,CAACF,cAAc,GAAG,CAAC,CAAC,CAAC,IAAIT,MAAM,CAACe,SAAS,CAACC,cAAc;MAEzG,IAAIH,iBAAiB,IAAIZ,YAAY,CAACS,GAAG,CAAC,mBAAmB,CAAC,EAAE;QAC5DT,YAAY,CAACgB,GAAG,CAAC,mBAAmB,EAAE,KAAK,CAAC;QAC5ChB,YAAY,CAACgB,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAAC;QAC5C,MAAMC,SAAS,GAAGjB,YAAY,CAACS,GAAG,CAAC,WAAW,CAAC;QAC/C,IAAIQ,SAAS,EAAEA,SAAS,CAAC,CAAC;QAC1B,OAAO,IAAI;MACf;;MAEA;MACA,MAAMC,eAAe,GAAGV,cAAc,GAAG,CAAC,IACtCG,UAAU,CAACD,QAAQ,CAACF,cAAc,GAAG,CAAC,CAAC,CAAC,CAACE,QAAQ,CAACF,cAAc,CAAC,CAAC,IAAIT,MAAM,CAACe,SAAS,CAACC,cAAc;MAEzG,IAAIG,eAAe,IAAIlB,YAAY,CAACS,GAAG,CAAC,oBAAoB,CAAC,EAAE;QAC3DT,YAAY,CAACgB,GAAG,CAAC,mBAAmB,EAAE,IAAI,CAAC;QAC3ChB,YAAY,CAACgB,GAAG,CAAC,oBAAoB,EAAE,KAAK,CAAC;QAC7C,MAAMG,WAAW,GAAGnB,YAAY,CAACS,GAAG,CAAC,aAAa,CAAC;QACnD,IAAIU,WAAW,EAAEA,WAAW,CAAC,CAAC;QAC9B,OAAO,IAAI;MACf;MAEA,OAAO,KAAK;IAChB,CAAC,SAAS;MACN,IAAI,CAAChB,eAAe,GAAG,KAAK;IAChC;EACJ;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}