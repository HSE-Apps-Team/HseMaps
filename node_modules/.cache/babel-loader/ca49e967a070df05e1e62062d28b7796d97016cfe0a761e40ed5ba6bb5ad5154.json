{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nvar _pathCache = /*#__PURE__*/_classPrivateFieldLooseKey(\"pathCache\");\nvar _nodeSelectorCache = /*#__PURE__*/_classPrivateFieldLooseKey(\"nodeSelectorCache\");\n/**\r\n * @module PathfindingModule\r\n * @description Implements optimized pathfinding algorithms using Floyd-Warshall's pre-computed matrices.\r\n * Provides efficient path reconstruction and node selection based on distance heuristics.\r\n */\n\nexport class PathfindingModule {\n  /**\r\n   * Validates input parameters for path construction\r\n   * @private\r\n   */\n  static validatePathInput(matrix, start, end) {\n    return matrix && Number.isInteger(start) && Number.isInteger(end) && start >= 0 && end >= 0 && matrix[start] !== undefined;\n  }\n\n  /**\r\n   * Reconstructs optimal path using pre-computed next vertex information\r\n   * @param {number[][]} nextMatrix - Pre-computed matrix where nextMatrix[i][j] represents \r\n   *                                  the next vertex to visit when going from i to j\r\n   * @param {number} start - Index of starting vertex in the graph\r\n   * @param {number} end - Index of destination vertex in the graph\r\n   * @returns {number[]} Array of vertex indices forming the shortest path from start to end.\r\n   *                     Returns empty array if no valid path exists.\r\n   * @example\r\n   * const path = PathfindingModule.constructPath(nextMatrix, 0, 5);\r\n   * // Returns [0, 2, 3, 5] representing the optimal path from vertex 0 to 5\r\n   */\n  static constructPath(nextMatrix, start, end) {\n    // Check cache first\n    const cacheKey = `${start}-${end}`;\n    if (_classPrivateFieldLooseBase(this, _pathCache)[_pathCache].has(cacheKey)) {\n      return [..._classPrivateFieldLooseBase(this, _pathCache)[_pathCache].get(cacheKey)]; // Return copy to prevent mutation\n    }\n    if (!this.validatePathInput(nextMatrix, start, end)) return [];\n    const path = [start];\n    let current = start;\n\n    // Fast path for direct connection\n    if (start === end) return path;\n\n    // Limited iterations to prevent infinite loops in corrupted matrices\n    const maxIterations = nextMatrix.length;\n    let iterations = 0;\n    while (current !== end && iterations < maxIterations) {\n      // Fast access with safety check\n      const nextRow = nextMatrix[current];\n      if (!nextRow) break;\n      const next = nextRow[end];\n      if (next == null) break;\n      path.push(next);\n      current = next;\n      iterations++;\n    }\n\n    // Only cache valid paths that reach the destination\n    if (current === end) {\n      _classPrivateFieldLooseBase(this, _pathCache)[_pathCache].set(cacheKey, [...path]);\n    }\n    return path;\n  }\n\n  /**\r\n   * Determines optimal node from candidates based on distance to goals\r\n   * @param {number[]} nodes - Array of candidate node indices to evaluate\r\n   * @param {number[]} goals - Array of target node indices to measure against\r\n   * @param {number[][]} distMatrix - Matrix of pre-computed distances between all vertices\r\n   * @returns {number|null} Index of the optimal node, or null if no valid node found\r\n   * @example\r\n   * const bestNode = PathfindingModule.selectBestNode([1,2,3], [10,11], distMatrix);\r\n   * // Returns the node index from [1,2,3] that's closest to either 10 or 11\r\n   */\n  static selectBestNode(nodes, goals, distMatrix) {\n    if (!(nodes !== null && nodes !== void 0 && nodes.length) || !(goals !== null && goals !== void 0 && goals.length) || !distMatrix) return null;\n\n    // Generate cache key for this specific input\n    const cacheKey = `${nodes.join(',')}-${goals.join(',')}`;\n    if (_classPrivateFieldLooseBase(this, _nodeSelectorCache)[_nodeSelectorCache].has(cacheKey)) {\n      return _classPrivateFieldLooseBase(this, _nodeSelectorCache)[_nodeSelectorCache].get(cacheKey);\n    }\n    let bestNode = null;\n    let bestDistance = Infinity;\n\n    // Process nodes with potential early termination\n    for (const node of nodes) {\n      let minDistToGoal = Infinity;\n\n      // Find minimum distance to any goal\n      for (const goal of goals) {\n        var _ref;\n        // Access potentially undefined values safely\n        const dist = (_ref = distMatrix[node] && distMatrix[node][goal]) !== null && _ref !== void 0 ? _ref : Infinity;\n\n        // Early exit if we found a direct connection (distance 1)\n        if (dist === 1) {\n          _classPrivateFieldLooseBase(this, _nodeSelectorCache)[_nodeSelectorCache].set(cacheKey, node);\n          return node;\n        }\n        minDistToGoal = Math.min(minDistToGoal, dist);\n      }\n      if (minDistToGoal < bestDistance) {\n        bestDistance = minDistToGoal;\n        bestNode = node;\n      }\n    }\n\n    // Cache result for future calls with same inputs\n    _classPrivateFieldLooseBase(this, _nodeSelectorCache)[_nodeSelectorCache].set(cacheKey, bestNode);\n    return bestNode;\n  }\n\n  /**\r\n   * Finds shortest path between rooms using precomputed matrices\r\n   * @static\r\n   * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n   * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n   * @param {string} startRoom - Starting room identifier\r\n   * @param {string} endRoom - Ending room identifier\r\n   * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n   * @returns {number[]} Array of vertex indices forming the shortest path\r\n   */\n  static findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\n    if (!rooms[startRoom] || !rooms[endRoom]) return [];\n    if (startRoom === endRoom) return [];\n    const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\n    if (startNode == null) return [];\n    const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\n    if (endNode == null) return [];\n    return this.constructPath(nextMatrix, startNode, endNode);\n  }\n\n  /**\r\n   * Clears internal caches to free memory\r\n   * @returns {void}\r\n   */\n  static clearCache() {\n    _classPrivateFieldLooseBase(this, _pathCache)[_pathCache].clear();\n    _classPrivateFieldLooseBase(this, _nodeSelectorCache)[_nodeSelectorCache].clear();\n  }\n}\n// Cache for previously calculated paths\nObject.defineProperty(PathfindingModule, _pathCache, {\n  writable: true,\n  value: new Map()\n});\nObject.defineProperty(PathfindingModule, _nodeSelectorCache, {\n  writable: true,\n  value: new Map()\n});","map":{"version":3,"names":["PathfindingModule","validatePathInput","matrix","start","end","Number","isInteger","undefined","constructPath","nextMatrix","cacheKey","_classPrivateFieldLooseBase","_pathCache","has","get","path","current","maxIterations","length","iterations","nextRow","next","push","set","selectBestNode","nodes","goals","distMatrix","join","_nodeSelectorCache","bestNode","bestDistance","Infinity","node","minDistToGoal","goal","_ref","dist","Math","min","findShortestPath","startRoom","endRoom","rooms","startNode","endNode","clearCache","clear","Object","defineProperty","writable","value","Map"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/PathfindingModule.js"],"sourcesContent":["/**\r\n * @module PathfindingModule\r\n * @description Implements optimized pathfinding algorithms using Floyd-Warshall's pre-computed matrices.\r\n * Provides efficient path reconstruction and node selection based on distance heuristics.\r\n */\r\n\r\nexport class PathfindingModule {\r\n    // Cache for previously calculated paths\r\n    static #pathCache = new Map();\r\n    static #nodeSelectorCache = new Map();\r\n    \r\n    /**\r\n     * Validates input parameters for path construction\r\n     * @private\r\n     */\r\n    static validatePathInput(matrix, start, end) {\r\n        return matrix && \r\n               Number.isInteger(start) && \r\n               Number.isInteger(end) && \r\n               start >= 0 && \r\n               end >= 0 && \r\n               matrix[start] !== undefined;\r\n    }\r\n    \r\n    /**\r\n     * Reconstructs optimal path using pre-computed next vertex information\r\n     * @param {number[][]} nextMatrix - Pre-computed matrix where nextMatrix[i][j] represents \r\n     *                                  the next vertex to visit when going from i to j\r\n     * @param {number} start - Index of starting vertex in the graph\r\n     * @param {number} end - Index of destination vertex in the graph\r\n     * @returns {number[]} Array of vertex indices forming the shortest path from start to end.\r\n     *                     Returns empty array if no valid path exists.\r\n     * @example\r\n     * const path = PathfindingModule.constructPath(nextMatrix, 0, 5);\r\n     * // Returns [0, 2, 3, 5] representing the optimal path from vertex 0 to 5\r\n     */\r\n    static constructPath(nextMatrix, start, end) {\r\n        // Check cache first\r\n        const cacheKey = `${start}-${end}`;\r\n        if (this.#pathCache.has(cacheKey)) {\r\n            return [...this.#pathCache.get(cacheKey)]; // Return copy to prevent mutation\r\n        }\r\n        \r\n        if (!this.validatePathInput(nextMatrix, start, end)) return [];\r\n        \r\n        const path = [start];\r\n        let current = start;\r\n        \r\n        // Fast path for direct connection\r\n        if (start === end) return path;\r\n        \r\n        // Limited iterations to prevent infinite loops in corrupted matrices\r\n        const maxIterations = nextMatrix.length;\r\n        let iterations = 0;\r\n        \r\n        while (current !== end && iterations < maxIterations) {\r\n            // Fast access with safety check\r\n            const nextRow = nextMatrix[current];\r\n            if (!nextRow) break;\r\n            \r\n            const next = nextRow[end];\r\n            if (next == null) break;\r\n            \r\n            path.push(next);\r\n            current = next;\r\n            iterations++;\r\n        }\r\n        \r\n        // Only cache valid paths that reach the destination\r\n        if (current === end) {\r\n            this.#pathCache.set(cacheKey, [...path]);\r\n        }\r\n        \r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Determines optimal node from candidates based on distance to goals\r\n     * @param {number[]} nodes - Array of candidate node indices to evaluate\r\n     * @param {number[]} goals - Array of target node indices to measure against\r\n     * @param {number[][]} distMatrix - Matrix of pre-computed distances between all vertices\r\n     * @returns {number|null} Index of the optimal node, or null if no valid node found\r\n     * @example\r\n     * const bestNode = PathfindingModule.selectBestNode([1,2,3], [10,11], distMatrix);\r\n     * // Returns the node index from [1,2,3] that's closest to either 10 or 11\r\n     */\r\n    static selectBestNode(nodes, goals, distMatrix) {\r\n        if (!nodes?.length || !goals?.length || !distMatrix) return null;\r\n        \r\n        // Generate cache key for this specific input\r\n        const cacheKey = `${nodes.join(',')}-${goals.join(',')}`;\r\n        if (this.#nodeSelectorCache.has(cacheKey)) {\r\n            return this.#nodeSelectorCache.get(cacheKey);\r\n        }\r\n        \r\n        let bestNode = null;\r\n        let bestDistance = Infinity;\r\n        \r\n        // Process nodes with potential early termination\r\n        for (const node of nodes) {\r\n            let minDistToGoal = Infinity;\r\n            \r\n            // Find minimum distance to any goal\r\n            for (const goal of goals) {\r\n                // Access potentially undefined values safely\r\n                const dist = (distMatrix[node] && distMatrix[node][goal]) ?? Infinity;\r\n                \r\n                // Early exit if we found a direct connection (distance 1)\r\n                if (dist === 1) {\r\n                    this.#nodeSelectorCache.set(cacheKey, node);\r\n                    return node;\r\n                }\r\n                \r\n                minDistToGoal = Math.min(minDistToGoal, dist);\r\n            }\r\n            \r\n            if (minDistToGoal < bestDistance) {\r\n                bestDistance = minDistToGoal;\r\n                bestNode = node;\r\n            }\r\n        }\r\n        \r\n        // Cache result for future calls with same inputs\r\n        this.#nodeSelectorCache.set(cacheKey, bestNode);\r\n        return bestNode;\r\n    }\r\n    \r\n    /**\r\n     * Finds shortest path between rooms using precomputed matrices\r\n     * @static\r\n     * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n     * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n     * @param {string} startRoom - Starting room identifier\r\n     * @param {string} endRoom - Ending room identifier\r\n     * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n     * @returns {number[]} Array of vertex indices forming the shortest path\r\n     */\r\n    static findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\r\n        if (!rooms[startRoom] || !rooms[endRoom]) return [];\r\n        if (startRoom === endRoom) return [];\r\n\r\n        const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\r\n        if (startNode == null) return [];\r\n\r\n        const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\r\n        if (endNode == null) return [];\r\n\r\n        return this.constructPath(nextMatrix, startNode, endNode);\r\n    }\r\n\r\n    /**\r\n     * Clears internal caches to free memory\r\n     * @returns {void}\r\n     */\r\n    static clearCache() {\r\n        this.#pathCache.clear();\r\n        this.#nodeSelectorCache.clear();\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}