{"ast":null,"code":"class Stats{constructor(trials,func){this.count=0;this.mean=0;this.M2=0;// Sum of squares of differences from the mean\nthis.min=Infinity;this.max=-Infinity;for(var _len=arguments.length,args=new Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){args[_key-2]=arguments[_key];}for(let i=0;i<trials;i++){this.addValue(measureExecutionTime(func,...args));}}addValue(value){this.count++;const delta=value-this.mean;this.mean+=delta/this.count;this.M2+=delta*(value-this.mean);if(value<this.min){this.min=value;}if(value>this.max){this.max=value;}}getMean(){return this.mean;}getVariance(){return this.count>1?this.M2/this.count:0;}getStdDev(){return Math.sqrt(this.getVariance());}getMin(){return this.min;}getMax(){return this.max;}}function measureExecutionTime(func){const start=performance.now();for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}const result=func(...args);const end=performance.now();return end-start;}function flipKeyValuePairWithMultiNodes(obj){let flipped={};for(let node in obj){if(obj.hasOwnProperty(node)){obj[node].forEach(room=>{if(!flipped[room]){flipped[room]=[];}flipped[room].push(node);});}}return flipped;}export{Stats,measureExecutionTime,flipKeyValuePairWithMultiNodes};","map":{"version":3,"names":["Stats","constructor","trials","func","count","mean","M2","min","Infinity","max","_len","arguments","length","args","Array","_key","i","addValue","measureExecutionTime","value","delta","getMean","getVariance","getStdDev","Math","sqrt","getMin","getMax","start","performance","now","_len2","_key2","result","end","flipKeyValuePairWithMultiNodes","obj","flipped","node","hasOwnProperty","forEach","room","push"],"sources":["C:/Users/ampri/OneDrive/Documents/HseMaps/HseMaps/src/devTesting.js"],"sourcesContent":["    class Stats {\r\n      constructor(trials, func, ...args) {\r\n          this.count = 0;\r\n          this.mean = 0;\r\n          this.M2 = 0;  // Sum of squares of differences from the mean\r\n          this.min = Infinity;\r\n          this.max = -Infinity;\r\n          for (let i = 0; i < trials; i++) {\r\n              this.addValue(measureExecutionTime(func, ...args));\r\n          }\r\n      }\r\n  \r\n      addValue(value) {\r\n          this.count++;\r\n          \r\n          const delta = value - this.mean;\r\n          this.mean += delta / this.count;\r\n          this.M2 += delta * (value - this.mean);\r\n          \r\n          if (value < this.min) {\r\n              this.min = value;\r\n          }\r\n          if (value > this.max) {\r\n              this.max = value;\r\n          }\r\n      }\r\n  \r\n      getMean() {\r\n          return this.mean;\r\n      }\r\n  \r\n      getVariance() {\r\n          return this.count > 1 ? this.M2 / this.count : 0;\r\n      }\r\n  \r\n      getStdDev() {\r\n          return Math.sqrt(this.getVariance());\r\n      }\r\n  \r\n      getMin() {\r\n          return this.min;\r\n      }\r\n  \r\n      getMax() {\r\n          return this.max;\r\n      }\r\n  }\r\n\r\n  function measureExecutionTime(func, ...args) {\r\n    const start = performance.now();\r\n    const result = func(...args);\r\n    const end = performance.now();\r\n    return end-start;\r\n  }\r\n  function flipKeyValuePairWithMultiNodes(obj) {\r\n    let flipped = {};\r\n    \r\n    for (let node in obj) {\r\n        if (obj.hasOwnProperty(node)) {\r\n            obj[node].forEach(room => {\r\n                if (!flipped[room]) {\r\n                    flipped[room] = [];\r\n                }\r\n                flipped[room].push(node);\r\n            });\r\n        }\r\n    }\r\n    \r\n    return flipped;\r\n}\r\n\r\nexport { Stats, measureExecutionTime, flipKeyValuePairWithMultiNodes };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}