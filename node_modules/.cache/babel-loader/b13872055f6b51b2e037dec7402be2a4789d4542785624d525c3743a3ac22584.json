{"ast":null,"code":"/**\r\n * @module PathfindingModule\r\n * @description Handles pathfinding algorithms and route calculations between rooms\r\n */\n\nexport const PathfindingModule = {\n  /**\r\n   * @function constructPath\r\n   * @param {Array<Array<number>>} nextMatrix - Next vertex matrix for path reconstruction\r\n   * @param {number} start - Starting vertex index\r\n   * @param {number} end - Ending vertex index\r\n   * @returns {number[]} Array of vertex indices forming the path\r\n   */\n  constructPath(nextMatrix, start, end) {\n    var _nextMatrix$start;\n    if (!((_nextMatrix$start = nextMatrix[start]) !== null && _nextMatrix$start !== void 0 && _nextMatrix$start[end])) return [];\n    const path = [start];\n    while (path[path.length - 1] !== end) {\n      const next = nextMatrix[path[path.length - 1]][end];\n      if (!next && next !== 0) break;\n      path.push(next);\n    }\n    return path;\n  },\n  /**\r\n   * @function selectBestNode\r\n   * @param {number[]} nodes - Array of candidate nodes\r\n   * @param {number[]} goalNodes - Array of possible goal nodes\r\n   * @param {Array<Array<number>>} distMatrix - Distance matrix between nodes\r\n   * @returns {number|null} Best node index or null if no valid node found\r\n   */\n  selectBestNode(nodes, goalNodes, distMatrix) {\n    if (!(nodes !== null && nodes !== void 0 && nodes.length) || !(goalNodes !== null && goalNodes !== void 0 && goalNodes.length)) {\n      return null;\n    }\n    return nodes.reduce((best, node) => {\n      const minDist = Math.min(...goalNodes.map(goal => {\n        var _distMatrix$node$goal, _distMatrix$node;\n        return (_distMatrix$node$goal = (_distMatrix$node = distMatrix[node]) === null || _distMatrix$node === void 0 ? void 0 : _distMatrix$node[goal]) !== null && _distMatrix$node$goal !== void 0 ? _distMatrix$node$goal : Infinity;\n      }));\n      return minDist < best.dist ? {\n        node,\n        dist: minDist\n      } : best;\n    }, {\n      node: null,\n      dist: Infinity\n    }).node;\n  },\n  /**\r\n   * @function findShortestPath\r\n   * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n   * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n   * @param {string} startRoom - Starting room identifier\r\n   * @param {string} endRoom - Ending room identifier\r\n   * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n   * @returns {number[]} Array of vertex indices forming the shortest path\r\n   */\n  findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\n    if (!rooms[startRoom] || !rooms[endRoom]) {\n      return [];\n    }\n    if (startRoom === endRoom) {\n      return [];\n    }\n    const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\n    if (!startNode && startNode !== 0) {\n      return [];\n    }\n    const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\n    if (!endNode && endNode !== 0) {\n      return [];\n    }\n    return this.constructPath(nextMatrix, startNode, endNode);\n  }\n};","map":{"version":3,"names":["PathfindingModule","constructPath","nextMatrix","start","end","_nextMatrix$start","path","length","next","push","selectBestNode","nodes","goalNodes","distMatrix","reduce","best","node","minDist","Math","min","map","goal","_distMatrix$node$goal","_distMatrix$node","Infinity","dist","findShortestPath","startRoom","endRoom","rooms","startNode","endNode"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/PathfindingModule.js"],"sourcesContent":["/**\r\n * @module PathfindingModule\r\n * @description Handles pathfinding algorithms and route calculations between rooms\r\n */\r\n\r\nexport const PathfindingModule = {\r\n    /**\r\n     * @function constructPath\r\n     * @param {Array<Array<number>>} nextMatrix - Next vertex matrix for path reconstruction\r\n     * @param {number} start - Starting vertex index\r\n     * @param {number} end - Ending vertex index\r\n     * @returns {number[]} Array of vertex indices forming the path\r\n     */\r\n    constructPath(nextMatrix, start, end) {\r\n        if (!nextMatrix[start]?.[end]) return [];\r\n        const path = [start];\r\n        while (path[path.length - 1] !== end) {\r\n            const next = nextMatrix[path[path.length - 1]][end];\r\n            if (!next && next !== 0) break;\r\n            path.push(next);\r\n        }\r\n        return path;\r\n    },\r\n\r\n    /**\r\n     * @function selectBestNode\r\n     * @param {number[]} nodes - Array of candidate nodes\r\n     * @param {number[]} goalNodes - Array of possible goal nodes\r\n     * @param {Array<Array<number>>} distMatrix - Distance matrix between nodes\r\n     * @returns {number|null} Best node index or null if no valid node found\r\n     */\r\n    selectBestNode(nodes, goalNodes, distMatrix) {\r\n        if (!nodes?.length || !goalNodes?.length) {\r\n            return null;\r\n        }\r\n        return nodes.reduce((best, node) => {\r\n            const minDist = Math.min(...goalNodes.map(goal => \r\n                distMatrix[node]?.[goal] ?? Infinity\r\n            ));\r\n            return minDist < best.dist ? { node, dist: minDist } : best;\r\n        }, { node: null, dist: Infinity }).node;\r\n    },\r\n\r\n    /**\r\n     * @function findShortestPath\r\n     * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n     * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n     * @param {string} startRoom - Starting room identifier\r\n     * @param {string} endRoom - Ending room identifier\r\n     * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n     * @returns {number[]} Array of vertex indices forming the shortest path\r\n     */\r\n    findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\r\n        if (!rooms[startRoom] || !rooms[endRoom]) {\r\n            return [];\r\n        }\r\n\r\n        if (startRoom === endRoom) {\r\n            return [];\r\n        }\r\n\r\n        const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\r\n        if (!startNode && startNode !== 0) {\r\n            return [];\r\n        }\r\n\r\n        const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\r\n        if (!endNode && endNode !== 0) {\r\n            return [];\r\n        }\r\n\r\n        return this.constructPath(nextMatrix, startNode, endNode);\r\n    }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}