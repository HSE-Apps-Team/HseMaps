{"ast":null,"code":"/**\r\n * @module ResourceManager\r\n * @description Centralized resource management for images, caching, and loading\r\n */\nimport { StateManager } from './StateManager.js';\nconst importAll = r => {\n  const images = {};\n  r.keys().forEach(key => {\n    images[key.replace('./', '')] = r(key);\n  });\n  return images;\n};\nexport const ResourceManager = {\n  // Centralized caches\n  imageCache: new Map(),\n  loadingPromises: new Map(),\n  streetViewImages: importAll(require.context('../elements/StreetImages', false, /\\.(png|jpe?g|svg)$/)),\n  DEFAULT_IMAGE: '/assets/no-streetview.jpg',\n  /**\r\n   * Gets URL for a specific image\r\n   * @param {string} imageName - Image name to look up\r\n   * @returns {string} URL for the image or empty string if not found\r\n   */\n  getImageUrl(imageName) {\n    return this.streetViewImages[imageName] || '';\n  },\n  /**\r\n   * Preloads images for a path to ensure smooth navigation\r\n   * @param {Array<number>} path - The full navigation path\r\n   * @returns {Promise<void>} Promise that resolves when preloading is complete\r\n   */\n  async preloadImagesForPath(path) {\n    if (!(path !== null && path !== void 0 && path.length)) return;\n    const promises = [];\n    for (let i = 0; i < path.length - 1; i++) {\n      const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\n      if (!this.imageCache.has(imageKey) && !this.loadingPromises.has(imageKey)) {\n        const promise = this.loadImage(imageKey);\n        promises.push(promise);\n      }\n    }\n    await Promise.all(promises);\n  },\n  /**\r\n   * Loads a single image and caches it\r\n   * @param {string} imageKey - Key identifying the image to load\r\n   * @returns {Promise<string>} Promise resolving to the image URL\r\n   */\n  async loadImage(imageKey) {\n    if (this.imageCache.has(imageKey)) {\n      return this.imageCache.get(imageKey);\n    }\n    if (this.loadingPromises.has(imageKey)) {\n      return this.loadingPromises.get(imageKey);\n    }\n    const imageUrl = this.getImageUrl(imageKey);\n    if (!imageUrl) {\n      return this.DEFAULT_IMAGE;\n    }\n    const loadPromise = new Promise(resolve => {\n      const img = new Image();\n      img.onload = () => {\n        this.imageCache.set(imageKey, imageUrl);\n        this.loadingPromises.delete(imageKey);\n        resolve(imageUrl);\n      };\n      img.onerror = () => {\n        this.loadingPromises.delete(imageKey);\n        resolve(this.DEFAULT_IMAGE);\n      };\n      img.src = imageUrl;\n    });\n    this.loadingPromises.set(imageKey, loadPromise);\n    return loadPromise;\n  },\n  /**\r\n   * Gets the appropriate image for the current path segment\r\n   * @returns {string} URL of the image to display\r\n   */\n  getPathSegmentImage() {\n    const currentPathSegment = StateManager.get('currentPathSegment');\n    const path = StateManager.get('path');\n    if (!path || currentPathSegment === undefined || currentPathSegment < 0 || currentPathSegment >= path.length - 1) {\n      return this.DEFAULT_IMAGE;\n    }\n    const imageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\n\n    // Check cache first for immediate return\n    if (this.imageCache.has(imageKey)) {\n      return this.imageCache.get(imageKey);\n    }\n\n    // Start loading if not already loading\n    if (!this.loadingPromises.has(imageKey)) {\n      this.loadImage(imageKey);\n    }\n    return this.DEFAULT_IMAGE;\n  },\n  /**\r\n   * Clears all cached resources\r\n   */\n  clearCache() {\n    this.imageCache.clear();\n    this.loadingPromises.clear();\n  }\n};","map":{"version":3,"names":["StateManager","importAll","r","images","keys","forEach","key","replace","ResourceManager","imageCache","Map","loadingPromises","streetViewImages","require","context","DEFAULT_IMAGE","getImageUrl","imageName","preloadImagesForPath","path","length","promises","i","imageKey","has","promise","loadImage","push","Promise","all","get","imageUrl","loadPromise","resolve","img","Image","onload","set","delete","onerror","src","getPathSegmentImage","currentPathSegment","undefined","clearCache","clear"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/ResourceManager.js"],"sourcesContent":["/**\r\n * @module ResourceManager\r\n * @description Centralized resource management for images, caching, and loading\r\n */\r\nimport { StateManager } from './StateManager.js';\r\n\r\nconst importAll = (r) => {\r\n    const images = {};\r\n    r.keys().forEach((key) => {\r\n        images[key.replace('./', '')] = r(key);\r\n    });\r\n    return images;\r\n};\r\n\r\nexport const ResourceManager = {\r\n    // Centralized caches\r\n    imageCache: new Map(),\r\n    loadingPromises: new Map(),\r\n    streetViewImages: importAll(require.context('../elements/StreetImages', false, /\\.(png|jpe?g|svg)$/)),\r\n    DEFAULT_IMAGE: '/assets/no-streetview.jpg',\r\n\r\n    /**\r\n     * Gets URL for a specific image\r\n     * @param {string} imageName - Image name to look up\r\n     * @returns {string} URL for the image or empty string if not found\r\n     */\r\n    getImageUrl(imageName) {\r\n        return this.streetViewImages[imageName] || '';\r\n    },\r\n\r\n    /**\r\n     * Preloads images for a path to ensure smooth navigation\r\n     * @param {Array<number>} path - The full navigation path\r\n     * @returns {Promise<void>} Promise that resolves when preloading is complete\r\n     */\r\n    async preloadImagesForPath(path) {\r\n        if (!path?.length) return;\r\n        \r\n        const promises = [];\r\n        \r\n        for (let i = 0; i < path.length - 1; i++) {\r\n            const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\r\n            if (!this.imageCache.has(imageKey) && !this.loadingPromises.has(imageKey)) {\r\n                const promise = this.loadImage(imageKey);\r\n                promises.push(promise);\r\n            }\r\n        }\r\n        \r\n        await Promise.all(promises);\r\n    },\r\n    \r\n    /**\r\n     * Loads a single image and caches it\r\n     * @param {string} imageKey - Key identifying the image to load\r\n     * @returns {Promise<string>} Promise resolving to the image URL\r\n     */\r\n    async loadImage(imageKey) {\r\n        if (this.imageCache.has(imageKey)) {\r\n            return this.imageCache.get(imageKey);\r\n        }\r\n        \r\n        if (this.loadingPromises.has(imageKey)) {\r\n            return this.loadingPromises.get(imageKey);\r\n        }\r\n        \r\n        const imageUrl = this.getImageUrl(imageKey);\r\n        if (!imageUrl) {\r\n            return this.DEFAULT_IMAGE;\r\n        }\r\n        \r\n        const loadPromise = new Promise(resolve => {\r\n            const img = new Image();\r\n            img.onload = () => {\r\n                this.imageCache.set(imageKey, imageUrl);\r\n                this.loadingPromises.delete(imageKey);\r\n                resolve(imageUrl);\r\n            };\r\n            img.onerror = () => {\r\n                this.loadingPromises.delete(imageKey);\r\n                resolve(this.DEFAULT_IMAGE);\r\n            };\r\n            img.src = imageUrl;\r\n        });\r\n        \r\n        this.loadingPromises.set(imageKey, loadPromise);\r\n        return loadPromise;\r\n    },\r\n    \r\n    /**\r\n     * Gets the appropriate image for the current path segment\r\n     * @returns {string} URL of the image to display\r\n     */\r\n    getPathSegmentImage() {\r\n        const currentPathSegment = StateManager.get('currentPathSegment');\r\n        const path = StateManager.get('path');\r\n        \r\n        if (!path || currentPathSegment === undefined || \r\n            currentPathSegment < 0 || currentPathSegment >= path.length - 1) {\r\n            return this.DEFAULT_IMAGE;\r\n        }\r\n        \r\n        const imageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\r\n        \r\n        // Check cache first for immediate return\r\n        if (this.imageCache.has(imageKey)) {\r\n            return this.imageCache.get(imageKey);\r\n        }\r\n        \r\n        // Start loading if not already loading\r\n        if (!this.loadingPromises.has(imageKey)) {\r\n            this.loadImage(imageKey);\r\n        }\r\n        \r\n        return this.DEFAULT_IMAGE;\r\n    },\r\n    \r\n    /**\r\n     * Clears all cached resources\r\n     */\r\n    clearCache() {\r\n        this.imageCache.clear();\r\n        this.loadingPromises.clear();\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}