{"ast":null,"code":"/**\r\n * @module ResourceManager\r\n * @description Centralized resource management for images, caching, and loading\r\n */\nimport { StateManager } from './StateManager.js';\nconst importAll = r => {\n  const images = {};\n  r.keys().forEach(key => {\n    images[key.replace('./', '')] = r(key);\n  });\n  return images;\n};\nexport const ResourceManager = {\n  // Centralized caches\n  imageCache: new Map(),\n  loadingPromises: new Map(),\n  streetViewImages: importAll(require.context('../elements/StreetImages', false, /\\.(png|jpe?g|svg)$/)),\n  DEFAULT_IMAGE: '/assets/no-streetview.jpg',\n  /**\r\n   * Gets URL for a specific image\r\n   * @param {string} imageName - Image name to look up\r\n   * @returns {string} URL for the image or empty string if not found\r\n   */\n  getImageUrl(imageName) {\n    return this.streetViewImages[imageName] || '';\n  },\n  /**\r\n   * Preloads images for a path to ensure smooth navigation\r\n   * @param {Array<number>} path - The full navigation path\r\n   * @returns {Promise<void>} Promise that resolves when preloading is complete\r\n   */\n  async preloadImagesForPath(path) {\n    if (!(path !== null && path !== void 0 && path.length)) return;\n\n    // Calculate the preload window (next 5 segments)\n    const currentSegment = StateManager.get('currentPathSegment') || 0;\n    const endSegment = Math.min(currentSegment + 5, path.length - 1);\n    const promises = [];\n    for (let i = currentSegment; i < endSegment; i++) {\n      const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\n      if (!this.imageCache.has(imageKey) && !this.loadingPromises.has(imageKey)) {\n        const promise = this.loadImage(imageKey);\n        promises.push(promise);\n      }\n    }\n\n    // Clean up old cached images\n    if (this.imageCache.size > this.MAX_CACHE_SIZE) {\n      const keysToDelete = Array.from(this.imageCache.keys()).slice(0, this.imageCache.size - this.MAX_CACHE_SIZE);\n      keysToDelete.forEach(key => this.imageCache.delete(key));\n    }\n    await Promise.all(promises);\n  },\n  /**\r\n   * Loads a single image and caches it\r\n   * @param {string} imageKey - Key identifying the image to load\r\n   * @returns {Promise<string>} Promise resolving to the image URL\r\n   */\n  async loadImage(imageKey) {\n    if (this.imageCache.has(imageKey)) {\n      return this.imageCache.get(imageKey);\n    }\n    if (this.loadingPromises.has(imageKey)) {\n      return this.loadingPromises.get(imageKey);\n    }\n    const imageUrl = this.getImageUrl(imageKey);\n    if (!imageUrl) {\n      return this.DEFAULT_IMAGE;\n    }\n    const loadPromise = new Promise(resolve => {\n      const img = new Image();\n      img.onload = () => {\n        this.imageCache.set(imageKey, imageUrl);\n        this.loadingPromises.delete(imageKey);\n        resolve(imageUrl);\n      };\n      img.onerror = () => {\n        this.loadingPromises.delete(imageKey);\n        resolve(this.DEFAULT_IMAGE);\n      };\n      img.src = imageUrl;\n    });\n    this.loadingPromises.set(imageKey, loadPromise);\n    return loadPromise;\n  },\n  /**\r\n   * Gets the appropriate image for the current path segment\r\n   * @returns {string} URL of the image to display\r\n   */\n  getPathSegmentImage() {\n    const currentPathSegment = StateManager.get('currentPathSegment');\n    const path = StateManager.get('path');\n    if (!path || currentPathSegment === undefined || currentPathSegment < 0 || currentPathSegment >= path.length - 1) {\n      return this.DEFAULT_IMAGE;\n    }\n    const imageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\n\n    // Check cache first for immediate return\n    if (this.imageCache.has(imageKey)) {\n      return this.imageCache.get(imageKey);\n    }\n\n    // Start loading if not already loading\n    if (!this.loadingPromises.has(imageKey)) {\n      this.loadImage(imageKey);\n    }\n    return this.DEFAULT_IMAGE;\n  },\n  /**\r\n   * Clears all cached resources\r\n   */\n  clearCache() {\n    this.imageCache.clear();\n    this.loadingPromises.clear();\n  }\n};","map":{"version":3,"names":["StateManager","importAll","r","images","keys","forEach","key","replace","ResourceManager","imageCache","Map","loadingPromises","streetViewImages","require","context","DEFAULT_IMAGE","getImageUrl","imageName","preloadImagesForPath","path","length","currentSegment","get","endSegment","Math","min","promises","i","imageKey","has","promise","loadImage","push","size","MAX_CACHE_SIZE","keysToDelete","Array","from","slice","delete","Promise","all","imageUrl","loadPromise","resolve","img","Image","onload","set","onerror","src","getPathSegmentImage","currentPathSegment","undefined","clearCache","clear"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/ResourceManager.js"],"sourcesContent":["/**\r\n * @module ResourceManager\r\n * @description Centralized resource management for images, caching, and loading\r\n */\r\nimport { StateManager } from './StateManager.js';\r\n\r\nconst importAll = (r) => {\r\n    const images = {};\r\n    r.keys().forEach((key) => {\r\n        images[key.replace('./', '')] = r(key);\r\n    });\r\n    return images;\r\n};\r\n\r\nexport const ResourceManager = {\r\n    // Centralized caches\r\n    imageCache: new Map(),\r\n    loadingPromises: new Map(),\r\n    streetViewImages: importAll(require.context('../elements/StreetImages', false, /\\.(png|jpe?g|svg)$/)),\r\n    DEFAULT_IMAGE: '/assets/no-streetview.jpg',\r\n\r\n    /**\r\n     * Gets URL for a specific image\r\n     * @param {string} imageName - Image name to look up\r\n     * @returns {string} URL for the image or empty string if not found\r\n     */\r\n    getImageUrl(imageName) {\r\n        return this.streetViewImages[imageName] || '';\r\n    },\r\n\r\n    /**\r\n     * Preloads images for a path to ensure smooth navigation\r\n     * @param {Array<number>} path - The full navigation path\r\n     * @returns {Promise<void>} Promise that resolves when preloading is complete\r\n     */\r\n    async preloadImagesForPath(path) {\r\n        if (!path?.length) return;\r\n        \r\n        // Calculate the preload window (next 5 segments)\r\n        const currentSegment = StateManager.get('currentPathSegment') || 0;\r\n        const endSegment = Math.min(currentSegment + 5, path.length - 1);\r\n        \r\n        const promises = [];\r\n        \r\n        for (let i = currentSegment; i < endSegment; i++) {\r\n            const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\r\n            if (!this.imageCache.has(imageKey) && !this.loadingPromises.has(imageKey)) {\r\n                const promise = this.loadImage(imageKey);\r\n                promises.push(promise);\r\n            }\r\n        }\r\n        \r\n        // Clean up old cached images\r\n        if (this.imageCache.size > this.MAX_CACHE_SIZE) {\r\n            const keysToDelete = Array.from(this.imageCache.keys())\r\n                .slice(0, this.imageCache.size - this.MAX_CACHE_SIZE);\r\n            keysToDelete.forEach(key => this.imageCache.delete(key));\r\n        }\r\n        \r\n        await Promise.all(promises);\r\n    },\r\n    \r\n    /**\r\n     * Loads a single image and caches it\r\n     * @param {string} imageKey - Key identifying the image to load\r\n     * @returns {Promise<string>} Promise resolving to the image URL\r\n     */\r\n    async loadImage(imageKey) {\r\n        if (this.imageCache.has(imageKey)) {\r\n            return this.imageCache.get(imageKey);\r\n        }\r\n        \r\n        if (this.loadingPromises.has(imageKey)) {\r\n            return this.loadingPromises.get(imageKey);\r\n        }\r\n        \r\n        const imageUrl = this.getImageUrl(imageKey);\r\n        if (!imageUrl) {\r\n            return this.DEFAULT_IMAGE;\r\n        }\r\n        \r\n        const loadPromise = new Promise(resolve => {\r\n            const img = new Image();\r\n            img.onload = () => {\r\n                this.imageCache.set(imageKey, imageUrl);\r\n                this.loadingPromises.delete(imageKey);\r\n                resolve(imageUrl);\r\n            };\r\n            img.onerror = () => {\r\n                this.loadingPromises.delete(imageKey);\r\n                resolve(this.DEFAULT_IMAGE);\r\n            };\r\n            img.src = imageUrl;\r\n        });\r\n        \r\n        this.loadingPromises.set(imageKey, loadPromise);\r\n        return loadPromise;\r\n    },\r\n    \r\n    /**\r\n     * Gets the appropriate image for the current path segment\r\n     * @returns {string} URL of the image to display\r\n     */\r\n    getPathSegmentImage() {\r\n        const currentPathSegment = StateManager.get('currentPathSegment');\r\n        const path = StateManager.get('path');\r\n        \r\n        if (!path || currentPathSegment === undefined || \r\n            currentPathSegment < 0 || currentPathSegment >= path.length - 1) {\r\n            return this.DEFAULT_IMAGE;\r\n        }\r\n        \r\n        const imageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\r\n        \r\n        // Check cache first for immediate return\r\n        if (this.imageCache.has(imageKey)) {\r\n            return this.imageCache.get(imageKey);\r\n        }\r\n        \r\n        // Start loading if not already loading\r\n        if (!this.loadingPromises.has(imageKey)) {\r\n            this.loadImage(imageKey);\r\n        }\r\n        \r\n        return this.DEFAULT_IMAGE;\r\n    },\r\n    \r\n    /**\r\n     * Clears all cached resources\r\n     */\r\n    clearCache() {\r\n        this.imageCache.clear();\r\n        this.loadingPromises.clear();\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}