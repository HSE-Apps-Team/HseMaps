{"ast":null,"code":"import { DataModule } from \"./DataModule.js\";\nimport { StateManager } from './StateManager.js';\nimport { ImageModule } from './ImageModule.js';\n\n/**\r\n * @module StreetViewModule\r\n * @description Manages street view image retrieval and display for path segments,\r\n * including fallback handling for missing images and error states.\r\n */\nexport const StreetViewModule = {\n  /** @constant {string} DEFAULT_IMAGE - Path to the default fallback image */\n  DEFAULT_IMAGE: '/assets/no-streetview.jpg',\n  imageCache: new Map(),\n  loadingImages: new Set(),\n  worker: new Worker(new URL('../workers/ImageWorker.js', import.meta.url)),\n  constructor() {\n    this.worker.onmessage = async ({\n      data: {\n        key,\n        bitmap,\n        error\n      }\n    }) => {\n      if (bitmap) {\n        // Convert ImageBitmap to blob URL\n        const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(bitmap, 0, 0);\n        const blob = await canvas.convertToBlob();\n        const url = URL.createObjectURL(blob);\n        this.imageCache.set(key, url);\n        bitmap.close();\n      }\n      this.loadingImages.delete(key);\n    };\n  },\n  /**\r\n   * Preloads images for the given path.\r\n   * @param {Array} path - The path segments to preload images for\r\n   */\n  async preloadImagesForPath(path) {\n    if (!(path !== null && path !== void 0 && path.length)) return;\n    const promises = [];\n    for (let i = 0; i < path.length - 1; i++) {\n      const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\n      if (!this.imageCache.has(imageKey) && !this.loadingImages.has(imageKey)) {\n        this.loadingImages.add(imageKey);\n        const imageUrl = ImageModule.getImageUrl(imageKey);\n        if (imageUrl) {\n          this.worker.postMessage({\n            imageUrl,\n            key: imageKey\n          });\n        }\n      }\n    }\n  },\n  /**\r\n   * Retrieves the appropriate street view image for the current path segment.\r\n   * @returns {string} URL of the street view image or default image if none available\r\n   * @throws {Error} When image retrieval fails\r\n   */\n  getImage() {\n    console.log('getImage called');\n    const currentPathSegment = StateManager.get('currentPathSegment');\n    const path = StateManager.get('path');\n    console.log('Current path data:', {\n      currentPathSegment,\n      path,\n      cache: Array.from(this.imageCache.keys())\n    });\n    if (!path || currentPathSegment === undefined || currentPathSegment >= path.length - 1) {\n      console.warn('Invalid path segment:', {\n        currentPathSegment,\n        pathLength: path === null || path === void 0 ? void 0 : path.length\n      });\n      return this.DEFAULT_IMAGE;\n    }\n    const imageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\n    const cachedImage = this.imageCache.get(imageKey);\n    console.log('Image lookup:', {\n      imageKey,\n      cached: !!cachedImage\n    });\n    if (cachedImage) {\n      return cachedImage;\n    }\n    const imageUrl = ImageModule.getImageUrl(imageKey);\n    console.log('Fresh image URL:', imageUrl);\n    if (imageUrl) {\n      this.imageCache.set(imageKey, imageUrl);\n      return imageUrl;\n    }\n    console.warn('No image found for:', imageKey);\n    return this.DEFAULT_IMAGE;\n  },\n  /**\r\n   * Clears the image cache.\r\n   */\n  clearCache() {\n    // Revoke object URLs before clearing cache\n    this.imageCache.forEach(url => {\n      if (url.startsWith('blob:')) {\n        URL.revokeObjectURL(url);\n      }\n    });\n    this.imageCache.clear();\n    this.loadingImages.clear();\n  }\n};","map":{"version":3,"names":["DataModule","StateManager","ImageModule","StreetViewModule","DEFAULT_IMAGE","imageCache","Map","loadingImages","Set","worker","Worker","URL","import","meta","url","constructor","onmessage","data","key","bitmap","error","canvas","OffscreenCanvas","width","height","ctx","getContext","drawImage","blob","convertToBlob","createObjectURL","set","close","delete","preloadImagesForPath","path","length","promises","i","imageKey","has","add","imageUrl","getImageUrl","postMessage","getImage","console","log","currentPathSegment","get","cache","Array","from","keys","undefined","warn","pathLength","cachedImage","cached","clearCache","forEach","startsWith","revokeObjectURL","clear"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/StreetViewModule.js"],"sourcesContent":["import { DataModule } from \"./DataModule.js\";\r\nimport { StateManager } from './StateManager.js';\r\nimport { ImageModule } from './ImageModule.js';\r\n\r\n/**\r\n * @module StreetViewModule\r\n * @description Manages street view image retrieval and display for path segments,\r\n * including fallback handling for missing images and error states.\r\n */\r\nexport const StreetViewModule = {\r\n    /** @constant {string} DEFAULT_IMAGE - Path to the default fallback image */\r\n    DEFAULT_IMAGE: '/assets/no-streetview.jpg',\r\n    imageCache: new Map(),\r\n    loadingImages: new Set(),\r\n    worker: new Worker(new URL('../workers/ImageWorker.js', import.meta.url)),\r\n\r\n    constructor() {\r\n        this.worker.onmessage = async ({ data: { key, bitmap, error } }) => {\r\n            if (bitmap) {\r\n                // Convert ImageBitmap to blob URL\r\n                const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\r\n                const ctx = canvas.getContext('2d');\r\n                ctx.drawImage(bitmap, 0, 0);\r\n                const blob = await canvas.convertToBlob();\r\n                const url = URL.createObjectURL(blob);\r\n                this.imageCache.set(key, url);\r\n                bitmap.close();\r\n            }\r\n            this.loadingImages.delete(key);\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Preloads images for the given path.\r\n     * @param {Array} path - The path segments to preload images for\r\n     */\r\n    async preloadImagesForPath(path) {\r\n        if (!path?.length) return;\r\n        \r\n        const promises = [];\r\n        for (let i = 0; i < path.length - 1; i++) {\r\n            const imageKey = `${path[i]}-${path[i + 1]}.jpg`;\r\n            if (!this.imageCache.has(imageKey) && !this.loadingImages.has(imageKey)) {\r\n                this.loadingImages.add(imageKey);\r\n                const imageUrl = ImageModule.getImageUrl(imageKey);\r\n                if (imageUrl) {\r\n                    this.worker.postMessage({ imageUrl, key: imageKey });\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Retrieves the appropriate street view image for the current path segment.\r\n     * @returns {string} URL of the street view image or default image if none available\r\n     * @throws {Error} When image retrieval fails\r\n     */\r\n    getImage() {\r\n        console.log('getImage called');\r\n        const currentPathSegment = StateManager.get('currentPathSegment');\r\n        const path = StateManager.get('path');\r\n        console.log('Current path data:', { currentPathSegment, path, cache: Array.from(this.imageCache.keys()) });\r\n\r\n        if (!path || currentPathSegment === undefined || currentPathSegment >= path.length - 1) {\r\n            console.warn('Invalid path segment:', { currentPathSegment, pathLength: path?.length });\r\n            return this.DEFAULT_IMAGE;\r\n        }\r\n\r\n        const imageKey = `${path[currentPathSegment]}-${path[currentPathSegment + 1]}.jpg`;\r\n        const cachedImage = this.imageCache.get(imageKey);\r\n        console.log('Image lookup:', { imageKey, cached: !!cachedImage });\r\n        \r\n        if (cachedImage) {\r\n            return cachedImage;\r\n        }\r\n\r\n        const imageUrl = ImageModule.getImageUrl(imageKey);\r\n        console.log('Fresh image URL:', imageUrl);\r\n        \r\n        if (imageUrl) {\r\n            this.imageCache.set(imageKey, imageUrl);\r\n            return imageUrl;\r\n        }\r\n\r\n        console.warn('No image found for:', imageKey);\r\n        return this.DEFAULT_IMAGE;\r\n    },\r\n\r\n    /**\r\n     * Clears the image cache.\r\n     */\r\n    clearCache() {\r\n        // Revoke object URLs before clearing cache\r\n        this.imageCache.forEach(url => {\r\n            if (url.startsWith('blob:')) {\r\n                URL.revokeObjectURL(url);\r\n            }\r\n        });\r\n        this.imageCache.clear();\r\n        this.loadingImages.clear();\r\n    }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}