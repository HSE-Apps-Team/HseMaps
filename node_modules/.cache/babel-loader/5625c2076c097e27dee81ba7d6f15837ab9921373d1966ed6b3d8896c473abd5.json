{"ast":null,"code":"/**\r\n * @module PathfindingModule\r\n * @description Implements optimized pathfinding algorithms using Floyd-Warshall's pre-computed matrices.\r\n * Provides efficient path reconstruction and node selection based on distance heuristics.\r\n */\n\nexport class PathfindingModule {\n  /**\r\n   * Reconstructs optimal path using pre-computed next vertex information\r\n   * @param {number[][]} nextMatrix - Pre-computed matrix where nextMatrix[i][j] represents \r\n   *                                  the next vertex to visit when going from i to j\r\n   * @param {number} start - Index of starting vertex in the graph\r\n   * @param {number} end - Index of destination vertex in the graph\r\n   * @returns {number[]} Array of vertex indices forming the shortest path from start to end.\r\n   *                     Returns empty array if no valid path exists.\r\n   * @example\r\n   * const path = PathfindingModule.constructPath(nextMatrix, 0, 5);\r\n   * // Returns [0, 2, 3, 5] representing the optimal path from vertex 0 to 5\r\n   */\n  static constructPath(nextMatrix, start, end) {\n    if (!this.validateMatrix(nextMatrix, start, end)) return [];\n    const path = [start];\n    let current = start;\n    while (current !== end) {\n      var _nextMatrix$current;\n      const next = (_nextMatrix$current = nextMatrix[current]) === null || _nextMatrix$current === void 0 ? void 0 : _nextMatrix$current[end];\n      if (next == null) break;\n      path.push(next);\n      current = next;\n    }\n    return path;\n  }\n\n  /**\r\n   * Determines optimal node from candidates based on distance to goals\r\n   * @param {number[]} nodes - Array of candidate node indices to evaluate\r\n   * @param {number[]} goals - Array of target node indices to measure against\r\n   * @param {number[][]} distMatrix - Matrix of pre-computed distances between all vertices\r\n   * @returns {number|null} Index of the optimal node, or null if no valid node found\r\n   * @example\r\n   * const bestNode = PathfindingModule.selectBestNode([1,2,3], [10,11], distMatrix);\r\n   * // Returns the node index from [1,2,3] that's closest to either 10 or 11\r\n   */\n  static selectBestNode(nodes, goals, distMatrix) {\n    if (!(nodes !== null && nodes !== void 0 && nodes.length) || !(goals !== null && goals !== void 0 && goals.length)) return null;\n    return nodes.reduce((best, node) => {\n      const minDist = Math.min(...goals.map(goal => {\n        var _distMatrix$node$goal, _distMatrix$node;\n        return (_distMatrix$node$goal = (_distMatrix$node = distMatrix[node]) === null || _distMatrix$node === void 0 ? void 0 : _distMatrix$node[goal]) !== null && _distMatrix$node$goal !== void 0 ? _distMatrix$node$goal : Infinity;\n      }));\n      return minDist < best.dist ? {\n        node,\n        dist: minDist\n      } : best;\n    }, {\n      node: null,\n      dist: Infinity\n    }).node;\n  }\n\n  /**\r\n   * Finds shortest path between rooms using precomputed matrices\r\n   * @static\r\n   * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n   * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n   * @param {string} startRoom - Starting room identifier\r\n   * @param {string} endRoom - Ending room identifier\r\n   * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n   * @returns {number[]} Array of vertex indices forming the shortest path\r\n   */\n  static findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\n    if (!rooms[startRoom] || !rooms[endRoom]) return [];\n    if (startRoom === endRoom) return [];\n    const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\n    if (startNode == null) return [];\n    const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\n    if (endNode == null) return [];\n    return this.constructPath(nextMatrix, startNode, endNode);\n  }\n\n  /**\r\n   * Validates path finding input parameters\r\n   * @private\r\n   */\n  static validateMatrix(matrix, start, end) {\n    var _matrix$start;\n    return (matrix === null || matrix === void 0 ? void 0 : (_matrix$start = matrix[start]) === null || _matrix$start === void 0 ? void 0 : _matrix$start[end]) != null;\n  }\n}","map":{"version":3,"names":["PathfindingModule","constructPath","nextMatrix","start","end","validateMatrix","path","current","_nextMatrix$current","next","push","selectBestNode","nodes","goals","distMatrix","length","reduce","best","node","minDist","Math","min","map","goal","_distMatrix$node$goal","_distMatrix$node","Infinity","dist","findShortestPath","startRoom","endRoom","rooms","startNode","endNode","matrix","_matrix$start"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/PathfindingModule.js"],"sourcesContent":["/**\r\n * @module PathfindingModule\r\n * @description Implements optimized pathfinding algorithms using Floyd-Warshall's pre-computed matrices.\r\n * Provides efficient path reconstruction and node selection based on distance heuristics.\r\n */\r\n\r\nexport class PathfindingModule {\r\n    /**\r\n     * Reconstructs optimal path using pre-computed next vertex information\r\n     * @param {number[][]} nextMatrix - Pre-computed matrix where nextMatrix[i][j] represents \r\n     *                                  the next vertex to visit when going from i to j\r\n     * @param {number} start - Index of starting vertex in the graph\r\n     * @param {number} end - Index of destination vertex in the graph\r\n     * @returns {number[]} Array of vertex indices forming the shortest path from start to end.\r\n     *                     Returns empty array if no valid path exists.\r\n     * @example\r\n     * const path = PathfindingModule.constructPath(nextMatrix, 0, 5);\r\n     * // Returns [0, 2, 3, 5] representing the optimal path from vertex 0 to 5\r\n     */\r\n    static constructPath(nextMatrix, start, end) {\r\n        if (!this.validateMatrix(nextMatrix, start, end)) return [];\r\n        \r\n        const path = [start];\r\n        let current = start;\r\n        \r\n        while (current !== end) {\r\n            const next = nextMatrix[current]?.[end];\r\n            if (next == null) break;\r\n            path.push(next);\r\n            current = next;\r\n        }\r\n        \r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Determines optimal node from candidates based on distance to goals\r\n     * @param {number[]} nodes - Array of candidate node indices to evaluate\r\n     * @param {number[]} goals - Array of target node indices to measure against\r\n     * @param {number[][]} distMatrix - Matrix of pre-computed distances between all vertices\r\n     * @returns {number|null} Index of the optimal node, or null if no valid node found\r\n     * @example\r\n     * const bestNode = PathfindingModule.selectBestNode([1,2,3], [10,11], distMatrix);\r\n     * // Returns the node index from [1,2,3] that's closest to either 10 or 11\r\n     */\r\n    static selectBestNode(nodes, goals, distMatrix) {\r\n        if (!nodes?.length || !goals?.length) return null;\r\n        \r\n        return nodes.reduce((best, node) => {\r\n            const minDist = Math.min(...goals.map(goal => \r\n                distMatrix[node]?.[goal] ?? Infinity\r\n            ));\r\n            return minDist < best.dist ? { node, dist: minDist } : best;\r\n        }, { node: null, dist: Infinity }).node;\r\n    }\r\n\r\n    /**\r\n     * Finds shortest path between rooms using precomputed matrices\r\n     * @static\r\n     * @param {Array<Array<number>>} nextMatrix - Next vertex matrix\r\n     * @param {Array<Array<number>>} distMatrix - Distance matrix\r\n     * @param {string} startRoom - Starting room identifier\r\n     * @param {string} endRoom - Ending room identifier\r\n     * @param {Object.<string, number[]>} rooms - Room to vertices mapping\r\n     * @returns {number[]} Array of vertex indices forming the shortest path\r\n     */\r\n    static findShortestPath(nextMatrix, distMatrix, startRoom, endRoom, rooms) {\r\n        if (!rooms[startRoom] || !rooms[endRoom]) return [];\r\n        if (startRoom === endRoom) return [];\r\n\r\n        const startNode = this.selectBestNode(rooms[startRoom], rooms[endRoom], distMatrix);\r\n        if (startNode == null) return [];\r\n\r\n        const endNode = this.selectBestNode(rooms[endRoom], [startNode], distMatrix);\r\n        if (endNode == null) return [];\r\n\r\n        return this.constructPath(nextMatrix, startNode, endNode);\r\n    }\r\n\r\n    /**\r\n     * Validates path finding input parameters\r\n     * @private\r\n     */\r\n    static validateMatrix(matrix, start, end) {\r\n        return matrix?.[start]?.[end] != null;\r\n    }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}