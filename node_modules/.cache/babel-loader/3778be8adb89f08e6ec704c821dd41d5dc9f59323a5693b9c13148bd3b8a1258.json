{"ast":null,"code":"import { Config } from '../config/config.js';\nimport { StateManager } from './StateManager.js';\nimport { DOMCache } from './DOMCache.js';\nimport { ColorModule } from './ColorModule.js';\nimport { PathTransitionHandler } from './PathTransitionHandler.js';\nimport { RenderingModule } from './RenderingModule.js';\nimport { DataModule } from './DataModule.js';\nimport { StreetViewModule } from './StreetViewModule.js';\nimport { ImageModule } from './ImageModule.js';\n\n/**\r\n * @module UtilityModule\r\n * @description Provides utility functions for managing agent movement, path rendering,\r\n * and transition handling in the navigation system. Handles core functionality for\r\n * path visualization and agent positioning.\r\n */\nexport const UtilityModule = {\n  // Add new property to track current segment\n  lastPathSegment: null,\n  /**\r\n   * Updates the agent's position and orientation on the path based on current progress.\r\n   * @param {number} [margin=Config.DEFAULTS.MARGIN] - The margin to maintain around the agent when focusing\r\n   * @throws {Error} When essential UI elements are not available or when update fails\r\n   */\n  updateAgent(margin = Config.DEFAULTS.MARGIN) {\n    const elements = {\n      agent: DOMCache[Config.SVG.SELECTORS.AGENT],\n      path: DOMCache[`${Config.SVG.SELECTORS.GRAPH} > polyline`],\n      progbar: DOMCache[Config.SVG.SELECTORS.PROGBAR],\n      svg: DOMCache[Config.SVG.SELECTORS.SVGRAPH],\n      image: DOMCache[Config.SVG.SELECTORS.IMAGE],\n      svgg: DOMCache[Config.SVG.SELECTORS.SVG]\n    };\n\n    // Only warn if we're expecting elements to exist\n    const path = StateManager.get('path');\n    if (path !== null && path !== void 0 && path.length && !Object.values(elements).every(el => el === null || el === void 0 ? void 0 : el.isConnected)) {\n      console.debug('Some UI elements not yet available');\n      return;\n    }\n    try {\n      const {\n        agent,\n        path,\n        progbar,\n        svg,\n        svgg\n      } = elements;\n      const sliderValue = progbar.value;\n      const sliderCompletion = sliderValue / progbar.max;\n      const distanceDomain = StateManager.get('distanceDomain');\n      const currentPathSegment = distanceDomain.findIndex((e, i) => sliderValue >= distanceDomain[i] && sliderValue < (distanceDomain[i + 1] || Infinity));\n      if (this.lastPathSegment !== currentPathSegment) {\n        this.lastPathSegment = currentPathSegment;\n        this.updateStreetView(currentPathSegment);\n      }\n      StateManager.set('currentPathSegment', currentPathSegment);\n      const dist = StateManager.get('secondPathRendered') ? -(StateManager.get('totalDistance') - sliderValue - path.getTotalLength()) : sliderValue;\n      const point = path.getPointAtLength(dist);\n      const nextPoint = path.getPointAtLength(Number(dist) + 10);\n      this.updateAgentPosition(agent, point, nextPoint, svg, margin);\n      agent.style.fill = ColorModule.getColor(sliderCompletion);\n      svgg.style.backgroundImage = `url(${StreetViewModule.getImage()})`;\n      PathTransitionHandler.handleTransition();\n    } catch (error) {\n      console.error('Agent update failed:', error);\n    }\n  },\n  // Add new method for street view updates\n  updateStreetView(currentSegment) {\n    const streetViewContainer = document.getElementById('streetview-container');\n    if (!streetViewContainer) return;\n    const imageUrl = StreetViewModule.getImage();\n    streetViewContainer.style.backgroundImage = `url(\"${imageUrl}\")`;\n  },\n  /**\r\n   * Updates the agent's position and orientation on the SVG canvas.\r\n   * @param {SVGElement} agent - The agent element to be positioned\r\n   * @param {DOMPoint} point - The current point coordinates\r\n   * @param {DOMPoint} nextPoint - The next point coordinates for calculating orientation\r\n   * @param {SVGElement} svg - The SVG container element\r\n   * @param {number} margin - The margin to maintain when focusing\r\n   */\n  updateAgentPosition(agent, point, nextPoint, svg, margin) {\n    const dx = nextPoint.x - point.x;\n    const dy = nextPoint.y - point.y;\n    agent.cx.baseVal.value = point.x;\n    agent.cy.baseVal.value = point.y;\n    const orientation = 270 - Math.atan2(dy, dx) * 180 / Math.PI;\n    RenderingModule.focus(agent, margin);\n    svg.setAttribute(\"style\", `transform-origin: ${point.x}px ${point.y}px; transform: rotate(${orientation}deg)`);\n  },\n  /**\r\n   * Marks and renders the shortest path on the map, handling both regular paths\r\n   * and paths with stair transitions.\r\n   * @returns {Promise<void>} A promise that resolves when the path is rendered\r\n   * @throws {Error} When no valid path is available to render\r\n   */\n  markShortestPath() {\n    const path = StateManager.get('path');\n    if (!(path !== null && path !== void 0 && path.length)) {\n      console.warn('No path to render');\n      return;\n    }\n    RenderingModule.refresh();\n    StateManager.set('onPathEnd', () => {});\n    StateManager.set('onPathStart', () => {});\n    const {\n      distMatrix,\n      verts\n    } = DataModule.get();\n    StateManager.set('totalDistance', distMatrix[path[0]][path[path.length - 1]]);\n    StateManager.set('path', path);\n    const distanceDomain = [];\n    let accumulatedDist = 0;\n    for (let i = 0; i < path.length; i++) {\n      distanceDomain[i] = accumulatedDist;\n      if (i < path.length - 1 && distMatrix[path[i]][path[i + 1]] < Config.THRESHOLD.STAIR_DISTANCE) {\n        accumulatedDist += distMatrix[path[i]][path[i + 1]];\n      }\n    }\n    StateManager.set('distanceDomain', distanceDomain);\n    for (let i = 0; i < path.length - 1; i++) {\n      if (distMatrix[path[i]][path[i + 1]] === Config.THRESHOLD.STAIR_DISTANCE) {\n        this.handleStairTransition(path, i + 1, distMatrix, verts);\n        return RenderingModule.selectPath(path.slice(0, i + 1), verts, undefined, \"stairwell\");\n      }\n    }\n    this.lastPathSegment = null; // Reset segment tracker\n    this.updateStreetView(0); // Initialize with first segment\n    return RenderingModule.selectPath(path, verts);\n  },\n  /**\r\n   * Configures the transition between floors when stairs are encountered in the path.\r\n   * @param {Array<number>} path - The complete path array\r\n   * @param {number} index - The index where the stair transition occurs\r\n   * @param {Array<Array<number>>} distMatrix - The distance matrix\r\n   * @param {Array<Object>} verts - The vertices data\r\n   */\n  handleStairTransition(path, index, distMatrix, verts) {\n    StateManager.set('totalDistance', StateManager.get('totalDistance') - distMatrix[path[index - 1]][path[index]]);\n    StateManager.set('onPathStart', () => {\n      if (!StateManager.get('skipStart')()) {\n        RenderingModule.refresh();\n        StateManager.set('skipEnd', () => false);\n        StateManager.set('skipStart', () => true);\n        RenderingModule.selectPath(path.slice(0, index), verts, undefined, \"stairwell\");\n        this.configureScroll();\n      }\n    });\n    StateManager.set('onPathEnd', () => {\n      if (!StateManager.get('skipEnd')()) {\n        RenderingModule.refresh();\n        StateManager.set('skipStart', () => false);\n        StateManager.set('skipEnd', () => true);\n        RenderingModule.selectPath(path.slice(index), verts, \"stairwell\");\n        this.configureScroll();\n      }\n    });\n  },\n  /**\r\n   * Configures the scroll behavior and progress bar for path navigation.\r\n   * @throws {Error} When required DOM elements are not available\r\n   */\n  configureScroll() {\n    const element = DOMCache[Config.SVG.SELECTORS.AGENT];\n    if (!element) return;\n    RenderingModule.focus(element, Config.DEFAULTS.MARGIN);\n    const scroll = DOMCache[Config.SVG.SELECTORS.SCROLL];\n    const slider = DOMCache[Config.SVG.SELECTORS.PROGBAR];\n    slider.max = StateManager.get('totalDistance') - 0.0000001;\n    scroll.children[0].style.height = `${slider.max}px`;\n  }\n};","map":{"version":3,"names":["Config","StateManager","DOMCache","ColorModule","PathTransitionHandler","RenderingModule","DataModule","StreetViewModule","ImageModule","UtilityModule","lastPathSegment","updateAgent","margin","DEFAULTS","MARGIN","elements","agent","SVG","SELECTORS","AGENT","path","GRAPH","progbar","PROGBAR","svg","SVGRAPH","image","IMAGE","svgg","get","length","Object","values","every","el","isConnected","console","debug","sliderValue","value","sliderCompletion","max","distanceDomain","currentPathSegment","findIndex","e","i","Infinity","updateStreetView","set","dist","getTotalLength","point","getPointAtLength","nextPoint","Number","updateAgentPosition","style","fill","getColor","backgroundImage","getImage","handleTransition","error","currentSegment","streetViewContainer","document","getElementById","imageUrl","dx","x","dy","y","cx","baseVal","cy","orientation","Math","atan2","PI","focus","setAttribute","markShortestPath","warn","refresh","distMatrix","verts","accumulatedDist","THRESHOLD","STAIR_DISTANCE","handleStairTransition","selectPath","slice","undefined","index","configureScroll","element","scroll","SCROLL","slider","children","height"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/UtilityModule.js"],"sourcesContent":["import { Config } from '../config/config.js';\r\nimport { StateManager } from './StateManager.js';\r\nimport { DOMCache } from './DOMCache.js';\r\nimport { ColorModule } from './ColorModule.js';\r\nimport { PathTransitionHandler } from './PathTransitionHandler.js';\r\nimport { RenderingModule } from './RenderingModule.js';\r\nimport { DataModule } from './DataModule.js';\r\nimport { StreetViewModule } from './StreetViewModule.js';\r\nimport { ImageModule } from './ImageModule.js';\r\n\r\n/**\r\n * @module UtilityModule\r\n * @description Provides utility functions for managing agent movement, path rendering,\r\n * and transition handling in the navigation system. Handles core functionality for\r\n * path visualization and agent positioning.\r\n */\r\nexport const UtilityModule = {\r\n    // Add new property to track current segment\r\n    lastPathSegment: null,\r\n\r\n    /**\r\n     * Updates the agent's position and orientation on the path based on current progress.\r\n     * @param {number} [margin=Config.DEFAULTS.MARGIN] - The margin to maintain around the agent when focusing\r\n     * @throws {Error} When essential UI elements are not available or when update fails\r\n     */\r\n    updateAgent(margin = Config.DEFAULTS.MARGIN) {\r\n        const elements = {\r\n            agent: DOMCache[Config.SVG.SELECTORS.AGENT],\r\n            path: DOMCache[`${Config.SVG.SELECTORS.GRAPH} > polyline`],\r\n            progbar: DOMCache[Config.SVG.SELECTORS.PROGBAR],\r\n            svg: DOMCache[Config.SVG.SELECTORS.SVGRAPH],\r\n            image: DOMCache[Config.SVG.SELECTORS.IMAGE],\r\n            svgg: DOMCache[Config.SVG.SELECTORS.SVG]\r\n        };\r\n\r\n        // Only warn if we're expecting elements to exist\r\n        const path = StateManager.get('path');\r\n        if (path?.length && !Object.values(elements).every(el => el?.isConnected)) {\r\n            console.debug('Some UI elements not yet available');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const { agent, path, progbar, svg, svgg } = elements;\r\n            const sliderValue = progbar.value;\r\n            const sliderCompletion = sliderValue / progbar.max;\r\n            \r\n            const distanceDomain = StateManager.get('distanceDomain');\r\n            const currentPathSegment = distanceDomain.findIndex((e, i) => \r\n                sliderValue >= distanceDomain[i] && sliderValue < (distanceDomain[i + 1] || Infinity)\r\n            );\r\n            \r\n            if (this.lastPathSegment !== currentPathSegment) {\r\n                this.lastPathSegment = currentPathSegment;\r\n                this.updateStreetView(currentPathSegment);\r\n            }\r\n            \r\n            StateManager.set('currentPathSegment', currentPathSegment);\r\n\r\n            const dist = StateManager.get('secondPathRendered')\r\n                ? -(StateManager.get('totalDistance') - sliderValue - path.getTotalLength())\r\n                : sliderValue;\r\n\r\n            const point = path.getPointAtLength(dist);\r\n            const nextPoint = path.getPointAtLength(Number(dist) + 10);\r\n            \r\n            this.updateAgentPosition(agent, point, nextPoint, svg, margin);\r\n            agent.style.fill = ColorModule.getColor(sliderCompletion);\r\n            svgg.style.backgroundImage = `url(${StreetViewModule.getImage()})`;\r\n            \r\n            PathTransitionHandler.handleTransition();\r\n        } catch (error) {\r\n            console.error('Agent update failed:', error);\r\n        }\r\n    },\r\n\r\n    // Add new method for street view updates\r\n    updateStreetView(currentSegment) {\r\n        const streetViewContainer = document.getElementById('streetview-container');\r\n        if (!streetViewContainer) return;\r\n\r\n        const imageUrl = StreetViewModule.getImage();\r\n        streetViewContainer.style.backgroundImage = `url(\"${imageUrl}\")`;\r\n    },\r\n\r\n    /**\r\n     * Updates the agent's position and orientation on the SVG canvas.\r\n     * @param {SVGElement} agent - The agent element to be positioned\r\n     * @param {DOMPoint} point - The current point coordinates\r\n     * @param {DOMPoint} nextPoint - The next point coordinates for calculating orientation\r\n     * @param {SVGElement} svg - The SVG container element\r\n     * @param {number} margin - The margin to maintain when focusing\r\n     */\r\n    updateAgentPosition(agent, point, nextPoint, svg, margin) {\r\n        const dx = nextPoint.x - point.x;\r\n        const dy = nextPoint.y - point.y;\r\n        agent.cx.baseVal.value = point.x;\r\n        agent.cy.baseVal.value = point.y;\r\n        const orientation = 270 - (Math.atan2(dy, dx) * 180 / Math.PI);\r\n        RenderingModule.focus(agent, margin);\r\n        svg.setAttribute(\"style\", `transform-origin: ${point.x}px ${point.y}px; transform: rotate(${orientation}deg)`);\r\n    },\r\n\r\n    /**\r\n     * Marks and renders the shortest path on the map, handling both regular paths\r\n     * and paths with stair transitions.\r\n     * @returns {Promise<void>} A promise that resolves when the path is rendered\r\n     * @throws {Error} When no valid path is available to render\r\n     */\r\n    markShortestPath() {\r\n        const path = StateManager.get('path');\r\n        if (!path?.length) {\r\n            console.warn('No path to render');\r\n            return;\r\n        }\r\n\r\n        RenderingModule.refresh();\r\n        StateManager.set('onPathEnd', () => {});\r\n        StateManager.set('onPathStart', () => {});\r\n        const { distMatrix, verts } = DataModule.get();\r\n        StateManager.set('totalDistance', distMatrix[path[0]][path[path.length - 1]]);\r\n        StateManager.set('path', path);\r\n\r\n        const distanceDomain = [];\r\n        let accumulatedDist = 0;\r\n        \r\n        for (let i = 0; i < path.length; i++) {\r\n            distanceDomain[i] = accumulatedDist;\r\n            if (i < path.length - 1 && distMatrix[path[i]][path[i + 1]] < Config.THRESHOLD.STAIR_DISTANCE) {\r\n                accumulatedDist += distMatrix[path[i]][path[i + 1]];\r\n            }\r\n        }\r\n        \r\n        StateManager.set('distanceDomain', distanceDomain);\r\n        for (let i = 0; i < path.length - 1; i++) {\r\n            if (distMatrix[path[i]][path[i + 1]] === Config.THRESHOLD.STAIR_DISTANCE) {\r\n                this.handleStairTransition(path, i + 1, distMatrix, verts);\r\n                return RenderingModule.selectPath(path.slice(0, i + 1), verts, undefined, \"stairwell\");\r\n            }\r\n        }\r\n        this.lastPathSegment = null; // Reset segment tracker\r\n        this.updateStreetView(0); // Initialize with first segment\r\n        return RenderingModule.selectPath(path, verts);\r\n    },\r\n\r\n    /**\r\n     * Configures the transition between floors when stairs are encountered in the path.\r\n     * @param {Array<number>} path - The complete path array\r\n     * @param {number} index - The index where the stair transition occurs\r\n     * @param {Array<Array<number>>} distMatrix - The distance matrix\r\n     * @param {Array<Object>} verts - The vertices data\r\n     */\r\n    handleStairTransition(path, index, distMatrix, verts) {\r\n        StateManager.set('totalDistance', \r\n            StateManager.get('totalDistance') - distMatrix[path[index - 1]][path[index]]\r\n        );\r\n        \r\n        StateManager.set('onPathStart', () => {\r\n            if (!StateManager.get('skipStart')()) {\r\n                RenderingModule.refresh();\r\n                StateManager.set('skipEnd', () => false);\r\n                StateManager.set('skipStart', () => true);\r\n                \r\n                RenderingModule.selectPath(\r\n                    path.slice(0, index),\r\n                    verts, \r\n                    undefined, \r\n                    \"stairwell\"\r\n                );\r\n                this.configureScroll();\r\n            }\r\n        });\r\n\r\n        StateManager.set('onPathEnd', () => {\r\n            if (!StateManager.get('skipEnd')()) {\r\n                RenderingModule.refresh();\r\n                StateManager.set('skipStart', () => false);\r\n                StateManager.set('skipEnd', () => true);\r\n            \r\n                RenderingModule.selectPath(\r\n                    path.slice(index),\r\n                    verts,\r\n                    \"stairwell\"\r\n                );\r\n                this.configureScroll();\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Configures the scroll behavior and progress bar for path navigation.\r\n     * @throws {Error} When required DOM elements are not available\r\n     */\r\n    configureScroll() {\r\n        const element = DOMCache[Config.SVG.SELECTORS.AGENT];\r\n        if (!element) return;\r\n        \r\n        RenderingModule.focus(element, Config.DEFAULTS.MARGIN);\r\n        const scroll = DOMCache[Config.SVG.SELECTORS.SCROLL];\r\n        const slider = DOMCache[Config.SVG.SELECTORS.PROGBAR];\r\n        \r\n        slider.max = StateManager.get('totalDistance') - 0.0000001;\r\n        scroll.children[0].style.height = `${slider.max}px`;\r\n    }\r\n};"],"mappings":"AAAA,SAASA,MAAM,QAAQ,qBAAqB;AAC5C,SAASC,YAAY,QAAQ,mBAAmB;AAChD,SAASC,QAAQ,QAAQ,eAAe;AACxC,SAASC,WAAW,QAAQ,kBAAkB;AAC9C,SAASC,qBAAqB,QAAQ,4BAA4B;AAClE,SAASC,eAAe,QAAQ,sBAAsB;AACtD,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,gBAAgB,QAAQ,uBAAuB;AACxD,SAASC,WAAW,QAAQ,kBAAkB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAG;EACzB;EACAC,eAAe,EAAE,IAAI;EAErB;AACJ;AACA;AACA;AACA;EACIC,WAAWA,CAACC,MAAM,GAAGZ,MAAM,CAACa,QAAQ,CAACC,MAAM,EAAE;IACzC,MAAMC,QAAQ,GAAG;MACbC,KAAK,EAAEd,QAAQ,CAACF,MAAM,CAACiB,GAAG,CAACC,SAAS,CAACC,KAAK,CAAC;MAC3CC,IAAI,EAAElB,QAAQ,CAAC,GAAGF,MAAM,CAACiB,GAAG,CAACC,SAAS,CAACG,KAAK,aAAa,CAAC;MAC1DC,OAAO,EAAEpB,QAAQ,CAACF,MAAM,CAACiB,GAAG,CAACC,SAAS,CAACK,OAAO,CAAC;MAC/CC,GAAG,EAAEtB,QAAQ,CAACF,MAAM,CAACiB,GAAG,CAACC,SAAS,CAACO,OAAO,CAAC;MAC3CC,KAAK,EAAExB,QAAQ,CAACF,MAAM,CAACiB,GAAG,CAACC,SAAS,CAACS,KAAK,CAAC;MAC3CC,IAAI,EAAE1B,QAAQ,CAACF,MAAM,CAACiB,GAAG,CAACC,SAAS,CAACD,GAAG;IAC3C,CAAC;;IAED;IACA,MAAMG,IAAI,GAAGnB,YAAY,CAAC4B,GAAG,CAAC,MAAM,CAAC;IACrC,IAAIT,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEU,MAAM,IAAI,CAACC,MAAM,CAACC,MAAM,CAACjB,QAAQ,CAAC,CAACkB,KAAK,CAACC,EAAE,IAAIA,EAAE,aAAFA,EAAE,uBAAFA,EAAE,CAAEC,WAAW,CAAC,EAAE;MACvEC,OAAO,CAACC,KAAK,CAAC,oCAAoC,CAAC;MACnD;IACJ;IAEA,IAAI;MACA,MAAM;QAAErB,KAAK;QAAEI,IAAI;QAAEE,OAAO;QAAEE,GAAG;QAAEI;MAAK,CAAC,GAAGb,QAAQ;MACpD,MAAMuB,WAAW,GAAGhB,OAAO,CAACiB,KAAK;MACjC,MAAMC,gBAAgB,GAAGF,WAAW,GAAGhB,OAAO,CAACmB,GAAG;MAElD,MAAMC,cAAc,GAAGzC,YAAY,CAAC4B,GAAG,CAAC,gBAAgB,CAAC;MACzD,MAAMc,kBAAkB,GAAGD,cAAc,CAACE,SAAS,CAAC,CAACC,CAAC,EAAEC,CAAC,KACrDR,WAAW,IAAII,cAAc,CAACI,CAAC,CAAC,IAAIR,WAAW,IAAII,cAAc,CAACI,CAAC,GAAG,CAAC,CAAC,IAAIC,QAAQ,CACxF,CAAC;MAED,IAAI,IAAI,CAACrC,eAAe,KAAKiC,kBAAkB,EAAE;QAC7C,IAAI,CAACjC,eAAe,GAAGiC,kBAAkB;QACzC,IAAI,CAACK,gBAAgB,CAACL,kBAAkB,CAAC;MAC7C;MAEA1C,YAAY,CAACgD,GAAG,CAAC,oBAAoB,EAAEN,kBAAkB,CAAC;MAE1D,MAAMO,IAAI,GAAGjD,YAAY,CAAC4B,GAAG,CAAC,oBAAoB,CAAC,GAC7C,EAAE5B,YAAY,CAAC4B,GAAG,CAAC,eAAe,CAAC,GAAGS,WAAW,GAAGlB,IAAI,CAAC+B,cAAc,CAAC,CAAC,CAAC,GAC1Eb,WAAW;MAEjB,MAAMc,KAAK,GAAGhC,IAAI,CAACiC,gBAAgB,CAACH,IAAI,CAAC;MACzC,MAAMI,SAAS,GAAGlC,IAAI,CAACiC,gBAAgB,CAACE,MAAM,CAACL,IAAI,CAAC,GAAG,EAAE,CAAC;MAE1D,IAAI,CAACM,mBAAmB,CAACxC,KAAK,EAAEoC,KAAK,EAAEE,SAAS,EAAE9B,GAAG,EAAEZ,MAAM,CAAC;MAC9DI,KAAK,CAACyC,KAAK,CAACC,IAAI,GAAGvD,WAAW,CAACwD,QAAQ,CAACnB,gBAAgB,CAAC;MACzDZ,IAAI,CAAC6B,KAAK,CAACG,eAAe,GAAG,OAAOrD,gBAAgB,CAACsD,QAAQ,CAAC,CAAC,GAAG;MAElEzD,qBAAqB,CAAC0D,gBAAgB,CAAC,CAAC;IAC5C,CAAC,CAAC,OAAOC,KAAK,EAAE;MACZ3B,OAAO,CAAC2B,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;IAChD;EACJ,CAAC;EAED;EACAf,gBAAgBA,CAACgB,cAAc,EAAE;IAC7B,MAAMC,mBAAmB,GAAGC,QAAQ,CAACC,cAAc,CAAC,sBAAsB,CAAC;IAC3E,IAAI,CAACF,mBAAmB,EAAE;IAE1B,MAAMG,QAAQ,GAAG7D,gBAAgB,CAACsD,QAAQ,CAAC,CAAC;IAC5CI,mBAAmB,CAACR,KAAK,CAACG,eAAe,GAAG,QAAQQ,QAAQ,IAAI;EACpE,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIZ,mBAAmBA,CAACxC,KAAK,EAAEoC,KAAK,EAAEE,SAAS,EAAE9B,GAAG,EAAEZ,MAAM,EAAE;IACtD,MAAMyD,EAAE,GAAGf,SAAS,CAACgB,CAAC,GAAGlB,KAAK,CAACkB,CAAC;IAChC,MAAMC,EAAE,GAAGjB,SAAS,CAACkB,CAAC,GAAGpB,KAAK,CAACoB,CAAC;IAChCxD,KAAK,CAACyD,EAAE,CAACC,OAAO,CAACnC,KAAK,GAAGa,KAAK,CAACkB,CAAC;IAChCtD,KAAK,CAAC2D,EAAE,CAACD,OAAO,CAACnC,KAAK,GAAGa,KAAK,CAACoB,CAAC;IAChC,MAAMI,WAAW,GAAG,GAAG,GAAIC,IAAI,CAACC,KAAK,CAACP,EAAE,EAAEF,EAAE,CAAC,GAAG,GAAG,GAAGQ,IAAI,CAACE,EAAG;IAC9D1E,eAAe,CAAC2E,KAAK,CAAChE,KAAK,EAAEJ,MAAM,CAAC;IACpCY,GAAG,CAACyD,YAAY,CAAC,OAAO,EAAE,qBAAqB7B,KAAK,CAACkB,CAAC,MAAMlB,KAAK,CAACoB,CAAC,yBAAyBI,WAAW,MAAM,CAAC;EAClH,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;EACIM,gBAAgBA,CAAA,EAAG;IACf,MAAM9D,IAAI,GAAGnB,YAAY,CAAC4B,GAAG,CAAC,MAAM,CAAC;IACrC,IAAI,EAACT,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEU,MAAM,GAAE;MACfM,OAAO,CAAC+C,IAAI,CAAC,mBAAmB,CAAC;MACjC;IACJ;IAEA9E,eAAe,CAAC+E,OAAO,CAAC,CAAC;IACzBnF,YAAY,CAACgD,GAAG,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC,CAAC;IACvChD,YAAY,CAACgD,GAAG,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC,CAAC;IACzC,MAAM;MAAEoC,UAAU;MAAEC;IAAM,CAAC,GAAGhF,UAAU,CAACuB,GAAG,CAAC,CAAC;IAC9C5B,YAAY,CAACgD,GAAG,CAAC,eAAe,EAAEoC,UAAU,CAACjE,IAAI,CAAC,CAAC,CAAC,CAAC,CAACA,IAAI,CAACA,IAAI,CAACU,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAC7E7B,YAAY,CAACgD,GAAG,CAAC,MAAM,EAAE7B,IAAI,CAAC;IAE9B,MAAMsB,cAAc,GAAG,EAAE;IACzB,IAAI6C,eAAe,GAAG,CAAC;IAEvB,KAAK,IAAIzC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1B,IAAI,CAACU,MAAM,EAAEgB,CAAC,EAAE,EAAE;MAClCJ,cAAc,CAACI,CAAC,CAAC,GAAGyC,eAAe;MACnC,IAAIzC,CAAC,GAAG1B,IAAI,CAACU,MAAM,GAAG,CAAC,IAAIuD,UAAU,CAACjE,IAAI,CAAC0B,CAAC,CAAC,CAAC,CAAC1B,IAAI,CAAC0B,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG9C,MAAM,CAACwF,SAAS,CAACC,cAAc,EAAE;QAC3FF,eAAe,IAAIF,UAAU,CAACjE,IAAI,CAAC0B,CAAC,CAAC,CAAC,CAAC1B,IAAI,CAAC0B,CAAC,GAAG,CAAC,CAAC,CAAC;MACvD;IACJ;IAEA7C,YAAY,CAACgD,GAAG,CAAC,gBAAgB,EAAEP,cAAc,CAAC;IAClD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1B,IAAI,CAACU,MAAM,GAAG,CAAC,EAAEgB,CAAC,EAAE,EAAE;MACtC,IAAIuC,UAAU,CAACjE,IAAI,CAAC0B,CAAC,CAAC,CAAC,CAAC1B,IAAI,CAAC0B,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK9C,MAAM,CAACwF,SAAS,CAACC,cAAc,EAAE;QACtE,IAAI,CAACC,qBAAqB,CAACtE,IAAI,EAAE0B,CAAC,GAAG,CAAC,EAAEuC,UAAU,EAAEC,KAAK,CAAC;QAC1D,OAAOjF,eAAe,CAACsF,UAAU,CAACvE,IAAI,CAACwE,KAAK,CAAC,CAAC,EAAE9C,CAAC,GAAG,CAAC,CAAC,EAAEwC,KAAK,EAAEO,SAAS,EAAE,WAAW,CAAC;MAC1F;IACJ;IACA,IAAI,CAACnF,eAAe,GAAG,IAAI,CAAC,CAAC;IAC7B,IAAI,CAACsC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1B,OAAO3C,eAAe,CAACsF,UAAU,CAACvE,IAAI,EAAEkE,KAAK,CAAC;EAClD,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;EACII,qBAAqBA,CAACtE,IAAI,EAAE0E,KAAK,EAAET,UAAU,EAAEC,KAAK,EAAE;IAClDrF,YAAY,CAACgD,GAAG,CAAC,eAAe,EAC5BhD,YAAY,CAAC4B,GAAG,CAAC,eAAe,CAAC,GAAGwD,UAAU,CAACjE,IAAI,CAAC0E,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC1E,IAAI,CAAC0E,KAAK,CAAC,CAC/E,CAAC;IAED7F,YAAY,CAACgD,GAAG,CAAC,aAAa,EAAE,MAAM;MAClC,IAAI,CAAChD,YAAY,CAAC4B,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE;QAClCxB,eAAe,CAAC+E,OAAO,CAAC,CAAC;QACzBnF,YAAY,CAACgD,GAAG,CAAC,SAAS,EAAE,MAAM,KAAK,CAAC;QACxChD,YAAY,CAACgD,GAAG,CAAC,WAAW,EAAE,MAAM,IAAI,CAAC;QAEzC5C,eAAe,CAACsF,UAAU,CACtBvE,IAAI,CAACwE,KAAK,CAAC,CAAC,EAAEE,KAAK,CAAC,EACpBR,KAAK,EACLO,SAAS,EACT,WACJ,CAAC;QACD,IAAI,CAACE,eAAe,CAAC,CAAC;MAC1B;IACJ,CAAC,CAAC;IAEF9F,YAAY,CAACgD,GAAG,CAAC,WAAW,EAAE,MAAM;MAChC,IAAI,CAAChD,YAAY,CAAC4B,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE;QAChCxB,eAAe,CAAC+E,OAAO,CAAC,CAAC;QACzBnF,YAAY,CAACgD,GAAG,CAAC,WAAW,EAAE,MAAM,KAAK,CAAC;QAC1ChD,YAAY,CAACgD,GAAG,CAAC,SAAS,EAAE,MAAM,IAAI,CAAC;QAEvC5C,eAAe,CAACsF,UAAU,CACtBvE,IAAI,CAACwE,KAAK,CAACE,KAAK,CAAC,EACjBR,KAAK,EACL,WACJ,CAAC;QACD,IAAI,CAACS,eAAe,CAAC,CAAC;MAC1B;IACJ,CAAC,CAAC;EACN,CAAC;EAED;AACJ;AACA;AACA;EACIA,eAAeA,CAAA,EAAG;IACd,MAAMC,OAAO,GAAG9F,QAAQ,CAACF,MAAM,CAACiB,GAAG,CAACC,SAAS,CAACC,KAAK,CAAC;IACpD,IAAI,CAAC6E,OAAO,EAAE;IAEd3F,eAAe,CAAC2E,KAAK,CAACgB,OAAO,EAAEhG,MAAM,CAACa,QAAQ,CAACC,MAAM,CAAC;IACtD,MAAMmF,MAAM,GAAG/F,QAAQ,CAACF,MAAM,CAACiB,GAAG,CAACC,SAAS,CAACgF,MAAM,CAAC;IACpD,MAAMC,MAAM,GAAGjG,QAAQ,CAACF,MAAM,CAACiB,GAAG,CAACC,SAAS,CAACK,OAAO,CAAC;IAErD4E,MAAM,CAAC1D,GAAG,GAAGxC,YAAY,CAAC4B,GAAG,CAAC,eAAe,CAAC,GAAG,SAAS;IAC1DoE,MAAM,CAACG,QAAQ,CAAC,CAAC,CAAC,CAAC3C,KAAK,CAAC4C,MAAM,GAAG,GAAGF,MAAM,CAAC1D,GAAG,IAAI;EACvD;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}