{"ast":null,"code":"/**\r\n * @module PathTransitionHandler\r\n * @description Manages transitions between floors during path navigation\r\n */\n\nimport { Config } from '../config/config.js';\nimport { StateManager } from './StateManager.js';\nimport { DataModule } from './DataModule.js';\nexport const PathTransitionHandler = {\n  /**\r\n   * @type {boolean}\r\n   * @description Flag indicating if a floor transition is in progress\r\n   */\n  isTransitioning: false,\n  /**\r\n   * @function handleTransition\r\n   * @returns {boolean} True if transition occurred, false otherwise\r\n   * @description Handles floor transitions based on current path segment\r\n   */\n  handleTransition() {\n    if (this.isTransitioning) return false;\n    try {\n      this.isTransitioning = true;\n      const currentSegment = StateManager.get('currentPathSegment');\n      const fullPath = StateManager.get('path');\n      let isSecondFloor = fullPath[currentSegment] > Config.THRESHOLD.FLOOR_CHANGE;\n      if (fullPath[0] > Config.THRESHOLD.FLOOR_CHANGE) {\n        isSecondFloor = !isSecondFloor;\n      }\n      if (isSecondFloor && StateManager.get('firstPathRendered')) {\n        StateManager.set('firstPathRendered', false);\n        StateManager.set('secondPathRendered', true);\n        const onPathEnd = StateManager.get('onPathEnd');\n        if (onPathEnd) onPathEnd();\n        return true;\n      }\n      if (!isSecondFloor && StateManager.get('secondPathRendered')) {\n        StateManager.set('firstPathRendered', true);\n        StateManager.set('secondPathRendered', false);\n        const onPathStart = StateManager.get('onPathStart');\n        if (onPathStart) onPathStart();\n        return true;\n      }\n      return false;\n    } finally {\n      this.isTransitioning = false;\n    }\n  },\n  /**\r\n   * @function getStairIndex\r\n   * @param {number[]} path - Array of vertex indices\r\n   * @returns {number} Index of stair transition point or -1 if none found\r\n   * @description Finds the index where the path transitions between floors\r\n   */\n  getStairIndex(path) {\n    const {\n      distMatrix\n    } = DataModule.get();\n    for (let i = 0; i < path.length - 1; i++) {\n      if (distMatrix[path[i]][path[i + 1]] === Config.THRESHOLD.STAIR_DISTANCE) {\n        return i + 1;\n      }\n    }\n    return -1;\n  }\n};","map":{"version":3,"names":["Config","StateManager","DataModule","PathTransitionHandler","isTransitioning","handleTransition","currentSegment","get","fullPath","isSecondFloor","THRESHOLD","FLOOR_CHANGE","set","onPathEnd","onPathStart","getStairIndex","path","distMatrix","i","length","STAIR_DISTANCE"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/PathTransitionHandler.js"],"sourcesContent":["/**\r\n * @module PathTransitionHandler\r\n * @description Manages transitions between floors during path navigation\r\n */\r\n\r\nimport { Config } from '../config/config.js';\r\nimport { StateManager } from './StateManager.js';\r\nimport { DataModule } from './DataModule.js';\r\n\r\nexport const PathTransitionHandler = {\r\n    /**\r\n     * @type {boolean}\r\n     * @description Flag indicating if a floor transition is in progress\r\n     */\r\n    isTransitioning: false,\r\n\r\n    /**\r\n     * @function handleTransition\r\n     * @returns {boolean} True if transition occurred, false otherwise\r\n     * @description Handles floor transitions based on current path segment\r\n     */\r\n    handleTransition() {\r\n        if (this.isTransitioning) return false;\r\n        \r\n        try {\r\n            this.isTransitioning = true;\r\n            const currentSegment = StateManager.get('currentPathSegment');\r\n            const fullPath = StateManager.get('path');\r\n            let isSecondFloor = fullPath[currentSegment] > Config.THRESHOLD.FLOOR_CHANGE;\r\n            if (fullPath[0] > Config.THRESHOLD.FLOOR_CHANGE) {\r\n                isSecondFloor = !isSecondFloor;\r\n            }\r\n\r\n            if (isSecondFloor && StateManager.get('firstPathRendered')) {\r\n                StateManager.set('firstPathRendered', false);\r\n                StateManager.set('secondPathRendered', true);\r\n                const onPathEnd = StateManager.get('onPathEnd');\r\n                if (onPathEnd) onPathEnd();\r\n                return true;\r\n            }\r\n\r\n            if (!isSecondFloor && StateManager.get('secondPathRendered')) {\r\n                StateManager.set('firstPathRendered', true);\r\n                StateManager.set('secondPathRendered', false);\r\n                const onPathStart = StateManager.get('onPathStart');\r\n                if (onPathStart) onPathStart();\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        } finally {\r\n            this.isTransitioning = false;\r\n        }\r\n    },\r\n    \r\n    /**\r\n     * @function getStairIndex\r\n     * @param {number[]} path - Array of vertex indices\r\n     * @returns {number} Index of stair transition point or -1 if none found\r\n     * @description Finds the index where the path transitions between floors\r\n     */\r\n    getStairIndex(path){\r\n        const { distMatrix } = DataModule.get();\r\n        for (let i = 0; i < path.length-1; i++) {\r\n            if (distMatrix[path[i]][path[i + 1]] === Config.THRESHOLD.STAIR_DISTANCE) {\r\n                return i+1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,SAASA,MAAM,QAAQ,qBAAqB;AAC5C,SAASC,YAAY,QAAQ,mBAAmB;AAChD,SAASC,UAAU,QAAQ,iBAAiB;AAE5C,OAAO,MAAMC,qBAAqB,GAAG;EACjC;AACJ;AACA;AACA;EACIC,eAAe,EAAE,KAAK;EAEtB;AACJ;AACA;AACA;AACA;EACIC,gBAAgBA,CAAA,EAAG;IACf,IAAI,IAAI,CAACD,eAAe,EAAE,OAAO,KAAK;IAEtC,IAAI;MACA,IAAI,CAACA,eAAe,GAAG,IAAI;MAC3B,MAAME,cAAc,GAAGL,YAAY,CAACM,GAAG,CAAC,oBAAoB,CAAC;MAC7D,MAAMC,QAAQ,GAAGP,YAAY,CAACM,GAAG,CAAC,MAAM,CAAC;MACzC,IAAIE,aAAa,GAAGD,QAAQ,CAACF,cAAc,CAAC,GAAGN,MAAM,CAACU,SAAS,CAACC,YAAY;MAC5E,IAAIH,QAAQ,CAAC,CAAC,CAAC,GAAGR,MAAM,CAACU,SAAS,CAACC,YAAY,EAAE;QAC7CF,aAAa,GAAG,CAACA,aAAa;MAClC;MAEA,IAAIA,aAAa,IAAIR,YAAY,CAACM,GAAG,CAAC,mBAAmB,CAAC,EAAE;QACxDN,YAAY,CAACW,GAAG,CAAC,mBAAmB,EAAE,KAAK,CAAC;QAC5CX,YAAY,CAACW,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAAC;QAC5C,MAAMC,SAAS,GAAGZ,YAAY,CAACM,GAAG,CAAC,WAAW,CAAC;QAC/C,IAAIM,SAAS,EAAEA,SAAS,CAAC,CAAC;QAC1B,OAAO,IAAI;MACf;MAEA,IAAI,CAACJ,aAAa,IAAIR,YAAY,CAACM,GAAG,CAAC,oBAAoB,CAAC,EAAE;QAC1DN,YAAY,CAACW,GAAG,CAAC,mBAAmB,EAAE,IAAI,CAAC;QAC3CX,YAAY,CAACW,GAAG,CAAC,oBAAoB,EAAE,KAAK,CAAC;QAC7C,MAAME,WAAW,GAAGb,YAAY,CAACM,GAAG,CAAC,aAAa,CAAC;QACnD,IAAIO,WAAW,EAAEA,WAAW,CAAC,CAAC;QAC9B,OAAO,IAAI;MACf;MAEA,OAAO,KAAK;IAChB,CAAC,SAAS;MACN,IAAI,CAACV,eAAe,GAAG,KAAK;IAChC;EACJ,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;EACIW,aAAaA,CAACC,IAAI,EAAC;IACf,MAAM;MAAEC;IAAW,CAAC,GAAGf,UAAU,CAACK,GAAG,CAAC,CAAC;IACvC,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACG,MAAM,GAAC,CAAC,EAAED,CAAC,EAAE,EAAE;MACpC,IAAID,UAAU,CAACD,IAAI,CAACE,CAAC,CAAC,CAAC,CAACF,IAAI,CAACE,CAAC,GAAG,CAAC,CAAC,CAAC,KAAKlB,MAAM,CAACU,SAAS,CAACU,cAAc,EAAE;QACtE,OAAOF,CAAC,GAAC,CAAC;MACd;IACJ;IACA,OAAO,CAAC,CAAC;EACb;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}