{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\rexrt\\\\Downloads\\\\hsenavrepo\\\\HseMaps\\\\src\\\\modules\\\\NavigationController.js\";\n/**\r\n * @module NavigationController\r\n * @description Centralized controller for navigation state, transitions, and updates\r\n */\nimport { Config } from '../config/config.js';\nimport { StateManager } from './StateManager.js';\nimport { DOMCache } from './DOMCache.js';\nimport { ColorModule } from './ColorModule.js';\nimport { PathTransitionHandler } from './PathTransitionHandler.js';\nimport { RenderingModule } from './RenderingModule.js';\nimport { DataModule } from './DataModule.js';\nimport { ResourceManager } from './ResourceManager.js';\nimport ReactDOM from 'react-dom';\nimport { ImagePreloader } from '../Components/ImagePreloader'; // Updated import path\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const NavigationController = {\n  /**\r\n   * Updates the agent position based on current scroll/slider position\r\n   * @param {number} [margin=Config.DEFAULTS.MARGIN] - Margin for focusing\r\n   */\n  updateAgentPosition(margin = Config.DEFAULTS.MARGIN) {\n    const elements = {\n      agent: DOMCache[Config.SVG.SELECTORS.AGENT],\n      path: DOMCache[`${Config.SVG.SELECTORS.GRAPH} > polyline`],\n      progbar: DOMCache[Config.SVG.SELECTORS.PROGBAR],\n      svg: DOMCache[Config.SVG.SELECTORS.SVGRAPH],\n      svgdiv: DOMCache[Config.SVG.SELECTORS.SVGDIV]\n    };\n\n    // Validate elements\n    const path = StateManager.get('path');\n    if (path !== null && path !== void 0 && path.length && !Object.values(elements).every(el => el === null || el === void 0 ? void 0 : el.isConnected)) {\n      console.debug('Some UI elements not yet available');\n      return;\n    }\n    try {\n      const {\n        agent,\n        path,\n        progbar,\n        svg,\n        svgdiv\n      } = elements;\n      const sliderValue = progbar.value;\n      const distanceDomain = StateManager.get('distanceDomain');\n\n      // Calculate current path segment\n      const currentPathSegment = distanceDomain.findIndex((e, i) => sliderValue >= distanceDomain[i] && sliderValue < (distanceDomain[i + 1] || Infinity));\n\n      // Update state and background image\n      const prevSegment = StateManager.get('currentPathSegment');\n      StateManager.set('currentPathSegment', currentPathSegment);\n      if (prevSegment !== currentPathSegment) {\n        svgdiv.style.backgroundImage = `url(${ResourceManager.getPathSegmentImage()})`;\n      }\n\n      // Position the agent\n      const sliderCompletion = sliderValue / progbar.max;\n      const dist = StateManager.get('secondPathRendered') ? -(StateManager.get('totalDistance') - sliderValue - path.getTotalLength()) : sliderValue;\n      const point = path.getPointAtLength(dist);\n      const nextPoint = path.getPointAtLength(Number(dist) + 10);\n      this.positionAgent(agent, point, nextPoint, svg, margin);\n      agent.style.fill = ColorModule.getColor(sliderCompletion);\n\n      // Handle floor transitions\n      PathTransitionHandler.handleTransition();\n    } catch (error) {\n      console.error('Agent update failed:', error);\n    }\n  },\n  /**\r\n   * Positions and rotates the agent correctly on the path\r\n   */\n  positionAgent(agent, point, nextPoint, svg, margin) {\n    const dx = nextPoint.x - point.x;\n    const dy = nextPoint.y - point.y;\n    agent.cx.baseVal.value = point.x;\n    agent.cy.baseVal.value = point.y;\n    const orientation = 270 - Math.atan2(dy, dx) * 180 / Math.PI;\n    RenderingModule.focus(agent, margin);\n    svg.setAttribute(\"style\", `transform-origin: ${point.x}px ${point.y}px; transform: rotate(${orientation}deg)`);\n  },\n  /**\r\n   * Initializes and renders the path for navigation\r\n   */\n  async initializePath(path) {\n    if (!(path !== null && path !== void 0 && path.length)) {\n      console.warn('No path to render');\n      return;\n    }\n\n    // Reset the rendering state\n    RenderingModule.refresh();\n    StateManager.set('currentPathSegment', 0);\n    StateManager.set('onPathEnd', () => {});\n    StateManager.set('onPathStart', () => {});\n\n    // Calculate distance information\n    const {\n      distMatrix\n    } = DataModule.get();\n    StateManager.set('totalDistance', distMatrix[path[0]][path[path.length - 1]]);\n    StateManager.set('path', path);\n\n    // Preload images and continue initialization\n    try {\n      await this.preloadPathImages(path);\n      return this._completePathInitialization(path);\n    } catch (error) {\n      console.error('Failed to initialize path:', error);\n      return null;\n    }\n  },\n  async preloadPathImages(path) {\n    const imageUrls = await ResourceManager.preloadImagesForPath(path);\n    return new Promise(resolve => {\n      const container = document.createElement('div');\n      container.id = 'image-preloader';\n      document.body.appendChild(container);\n      ReactDOM.render(/*#__PURE__*/_jsxDEV(ImagePreloader, {\n        images: imageUrls,\n        onLoad: () => {\n          ReactDOM.unmountComponentAtNode(container);\n          container.remove();\n          resolve();\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 126,\n        columnNumber: 17\n      }, this), container);\n    });\n  },\n  /**\r\n   * Completes the path initialization after images are preloaded\r\n   * @private\r\n   */\n  _completePathInitialization(path) {\n    // Create distance domain for path navigation\n    const {\n      distMatrix,\n      verts\n    } = DataModule.get();\n    const distanceDomain = [];\n    let accumulatedDist = 0;\n    for (let i = 0; i < path.length; i++) {\n      distanceDomain[i] = accumulatedDist;\n      if (i < path.length - 1 && distMatrix[path[i]][path[i + 1]] < Config.THRESHOLD.STAIR_DISTANCE) {\n        accumulatedDist += distMatrix[path[i]][path[i + 1]];\n      }\n    }\n    StateManager.set('distanceDomain', distanceDomain);\n\n    // Handle stair transitions if present\n    for (let i = 0; i < path.length - 1; i++) {\n      if (distMatrix[path[i]][path[i + 1]] === Config.THRESHOLD.STAIR_DISTANCE) {\n        this.configureStairTransition(path, i + 1, distMatrix, verts);\n        return RenderingModule.selectPath(path.slice(0, i + 1), verts, undefined, \"stairwell\");\n      }\n    }\n    return RenderingModule.selectPath(path, verts);\n  },\n  /**\r\n   * Configures stair transitions between floors\r\n   */\n  configureStairTransition(path, index, distMatrix, verts) {\n    StateManager.set('totalDistance', StateManager.get('totalDistance') - distMatrix[path[index - 1]][path[index]]);\n    StateManager.set('onPathStart', () => {\n      if (!StateManager.get('skipStart')()) {\n        RenderingModule.refresh();\n        StateManager.set('skipEnd', () => false);\n        StateManager.set('skipStart', () => true);\n        RenderingModule.selectPath(path.slice(0, index), verts, undefined, \"stairwell\");\n        this.configureScroll();\n      }\n    });\n    StateManager.set('onPathEnd', () => {\n      if (!StateManager.get('skipEnd')()) {\n        RenderingModule.refresh();\n        StateManager.set('skipStart', () => false);\n        StateManager.set('skipEnd', () => true);\n        RenderingModule.selectPath(path.slice(index), verts, \"stairwell\");\n        this.configureScroll();\n      }\n    });\n  },\n  /**\r\n   * Configures scroll and slider for path navigation\r\n   */\n  configureScroll() {\n    const element = DOMCache[Config.SVG.SELECTORS.AGENT];\n    if (!element) return;\n    RenderingModule.focus(element, Config.DEFAULTS.MARGIN);\n    const scroll = DOMCache[Config.SVG.SELECTORS.SCROLL];\n    const slider = DOMCache[Config.SVG.SELECTORS.PROGBAR];\n    slider.max = StateManager.get('totalDistance') - 0.0000001;\n    scroll.children[0].style.height = `${slider.max}px`;\n  }\n};","map":{"version":3,"names":["Config","StateManager","DOMCache","ColorModule","PathTransitionHandler","RenderingModule","DataModule","ResourceManager","ReactDOM","ImagePreloader","jsxDEV","_jsxDEV","NavigationController","updateAgentPosition","margin","DEFAULTS","MARGIN","elements","agent","SVG","SELECTORS","AGENT","path","GRAPH","progbar","PROGBAR","svg","SVGRAPH","svgdiv","SVGDIV","get","length","Object","values","every","el","isConnected","console","debug","sliderValue","value","distanceDomain","currentPathSegment","findIndex","e","i","Infinity","prevSegment","set","style","backgroundImage","getPathSegmentImage","sliderCompletion","max","dist","getTotalLength","point","getPointAtLength","nextPoint","Number","positionAgent","fill","getColor","handleTransition","error","dx","x","dy","y","cx","baseVal","cy","orientation","Math","atan2","PI","focus","setAttribute","initializePath","warn","refresh","distMatrix","preloadPathImages","_completePathInitialization","imageUrls","preloadImagesForPath","Promise","resolve","container","document","createElement","id","body","appendChild","render","images","onLoad","unmountComponentAtNode","remove","fileName","_jsxFileName","lineNumber","columnNumber","verts","accumulatedDist","THRESHOLD","STAIR_DISTANCE","configureStairTransition","selectPath","slice","undefined","index","configureScroll","element","scroll","SCROLL","slider","children","height"],"sources":["C:/Users/rexrt/Downloads/hsenavrepo/HseMaps/src/modules/NavigationController.js"],"sourcesContent":["/**\r\n * @module NavigationController\r\n * @description Centralized controller for navigation state, transitions, and updates\r\n */\r\nimport { Config } from '../config/config.js';\r\nimport { StateManager } from './StateManager.js';\r\nimport { DOMCache } from './DOMCache.js';\r\nimport { ColorModule } from './ColorModule.js';\r\nimport { PathTransitionHandler } from './PathTransitionHandler.js';\r\nimport { RenderingModule } from './RenderingModule.js';\r\nimport { DataModule } from './DataModule.js';\r\nimport { ResourceManager } from './ResourceManager.js';\r\nimport ReactDOM from 'react-dom';\r\nimport { ImagePreloader } from '../Components/ImagePreloader';  // Updated import path\r\n\r\nexport const NavigationController = {\r\n    /**\r\n     * Updates the agent position based on current scroll/slider position\r\n     * @param {number} [margin=Config.DEFAULTS.MARGIN] - Margin for focusing\r\n     */\r\n    updateAgentPosition(margin = Config.DEFAULTS.MARGIN) {\r\n        const elements = {\r\n            agent: DOMCache[Config.SVG.SELECTORS.AGENT],\r\n            path: DOMCache[`${Config.SVG.SELECTORS.GRAPH} > polyline`],\r\n            progbar: DOMCache[Config.SVG.SELECTORS.PROGBAR],\r\n            svg: DOMCache[Config.SVG.SELECTORS.SVGRAPH],\r\n            svgdiv: DOMCache[Config.SVG.SELECTORS.SVGDIV]\r\n        };\r\n\r\n        // Validate elements\r\n        const path = StateManager.get('path');\r\n        if (path?.length && !Object.values(elements).every(el => el?.isConnected)) {\r\n            console.debug('Some UI elements not yet available');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const { agent, path, progbar, svg, svgdiv } = elements;\r\n            const sliderValue = progbar.value;\r\n            const distanceDomain = StateManager.get('distanceDomain');\r\n            \r\n            // Calculate current path segment\r\n            const currentPathSegment = distanceDomain.findIndex((e, i) => \r\n                sliderValue >= distanceDomain[i] && sliderValue < (distanceDomain[i + 1] || Infinity)\r\n            );\r\n            \r\n            // Update state and background image\r\n            const prevSegment = StateManager.get('currentPathSegment');\r\n            StateManager.set('currentPathSegment', currentPathSegment);\r\n            \r\n            if (prevSegment !== currentPathSegment) {\r\n                svgdiv.style.backgroundImage = `url(${ResourceManager.getPathSegmentImage()})`;\r\n            }\r\n            \r\n            // Position the agent\r\n            const sliderCompletion = sliderValue / progbar.max;\r\n            const dist = StateManager.get('secondPathRendered')\r\n                ? -(StateManager.get('totalDistance') - sliderValue - path.getTotalLength())\r\n                : sliderValue;\r\n            \r\n            const point = path.getPointAtLength(dist);\r\n            const nextPoint = path.getPointAtLength(Number(dist) + 10);\r\n            \r\n            this.positionAgent(agent, point, nextPoint, svg, margin);\r\n            agent.style.fill = ColorModule.getColor(sliderCompletion);\r\n            \r\n            // Handle floor transitions\r\n            PathTransitionHandler.handleTransition();\r\n        } catch (error) {\r\n            console.error('Agent update failed:', error);\r\n        }\r\n    },\r\n    \r\n    /**\r\n     * Positions and rotates the agent correctly on the path\r\n     */\r\n    positionAgent(agent, point, nextPoint, svg, margin) {\r\n        const dx = nextPoint.x - point.x;\r\n        const dy = nextPoint.y - point.y;\r\n        agent.cx.baseVal.value = point.x;\r\n        agent.cy.baseVal.value = point.y;\r\n        const orientation = 270 - (Math.atan2(dy, dx) * 180 / Math.PI);\r\n        RenderingModule.focus(agent, margin);\r\n        svg.setAttribute(\"style\", `transform-origin: ${point.x}px ${point.y}px; transform: rotate(${orientation}deg)`);\r\n    },\r\n    \r\n    /**\r\n     * Initializes and renders the path for navigation\r\n     */\r\n    async initializePath(path) {\r\n        if (!path?.length) {\r\n            console.warn('No path to render');\r\n            return;\r\n        }\r\n\r\n        // Reset the rendering state\r\n        RenderingModule.refresh();\r\n        StateManager.set('currentPathSegment', 0);\r\n        StateManager.set('onPathEnd', () => {});\r\n        StateManager.set('onPathStart', () => {});\r\n        \r\n        // Calculate distance information\r\n        const { distMatrix } = DataModule.get();\r\n        StateManager.set('totalDistance', distMatrix[path[0]][path[path.length - 1]]);\r\n        StateManager.set('path', path);\r\n        \r\n        // Preload images and continue initialization\r\n        try {\r\n            await this.preloadPathImages(path);\r\n            return this._completePathInitialization(path);\r\n        } catch (error) {\r\n            console.error('Failed to initialize path:', error);\r\n            return null;\r\n        }\r\n    },\r\n\r\n    async preloadPathImages(path) {\r\n        const imageUrls = await ResourceManager.preloadImagesForPath(path);\r\n        \r\n        return new Promise((resolve) => {\r\n            const container = document.createElement('div');\r\n            container.id = 'image-preloader';\r\n            document.body.appendChild(container);\r\n\r\n            ReactDOM.render(\r\n                <ImagePreloader \r\n                    images={imageUrls} \r\n                    onLoad={() => {\r\n                        ReactDOM.unmountComponentAtNode(container);\r\n                        container.remove();\r\n                        resolve();\r\n                    }}\r\n                />,\r\n                container\r\n            );\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Completes the path initialization after images are preloaded\r\n     * @private\r\n     */\r\n    _completePathInitialization(path) {\r\n        // Create distance domain for path navigation\r\n        const { distMatrix, verts } = DataModule.get();\r\n        const distanceDomain = [];\r\n        let accumulatedDist = 0;\r\n        \r\n        for (let i = 0; i < path.length; i++) {\r\n            distanceDomain[i] = accumulatedDist;\r\n            if (i < path.length - 1 && distMatrix[path[i]][path[i + 1]] < Config.THRESHOLD.STAIR_DISTANCE) {\r\n                accumulatedDist += distMatrix[path[i]][path[i + 1]];\r\n            }\r\n        }\r\n        \r\n        StateManager.set('distanceDomain', distanceDomain);\r\n        \r\n        // Handle stair transitions if present\r\n        for (let i = 0; i < path.length - 1; i++) {\r\n            if (distMatrix[path[i]][path[i + 1]] === Config.THRESHOLD.STAIR_DISTANCE) {\r\n                this.configureStairTransition(path, i + 1, distMatrix, verts);\r\n                return RenderingModule.selectPath(path.slice(0, i + 1), verts, undefined, \"stairwell\");\r\n            }\r\n        }\r\n        \r\n        return RenderingModule.selectPath(path, verts);\r\n    },\r\n\r\n    /**\r\n     * Configures stair transitions between floors\r\n     */\r\n    configureStairTransition(path, index, distMatrix, verts) {\r\n        StateManager.set('totalDistance', \r\n            StateManager.get('totalDistance') - distMatrix[path[index - 1]][path[index]]\r\n        );\r\n        \r\n        StateManager.set('onPathStart', () => {\r\n            if (!StateManager.get('skipStart')()) {\r\n                RenderingModule.refresh();\r\n                StateManager.set('skipEnd', () => false);\r\n                StateManager.set('skipStart', () => true);\r\n                \r\n                RenderingModule.selectPath(\r\n                    path.slice(0, index),\r\n                    verts, \r\n                    undefined, \r\n                    \"stairwell\"\r\n                );\r\n                this.configureScroll();\r\n            }\r\n        });\r\n\r\n        StateManager.set('onPathEnd', () => {\r\n            if (!StateManager.get('skipEnd')()) {\r\n                RenderingModule.refresh();\r\n                StateManager.set('skipStart', () => false);\r\n                StateManager.set('skipEnd', () => true);\r\n            \r\n                RenderingModule.selectPath(\r\n                    path.slice(index),\r\n                    verts,\r\n                    \"stairwell\"\r\n                );\r\n                this.configureScroll();\r\n            }\r\n        });\r\n    },\r\n    \r\n    /**\r\n     * Configures scroll and slider for path navigation\r\n     */\r\n    configureScroll() {\r\n        const element = DOMCache[Config.SVG.SELECTORS.AGENT];\r\n        if (!element) return;\r\n        \r\n        RenderingModule.focus(element, Config.DEFAULTS.MARGIN);\r\n        const scroll = DOMCache[Config.SVG.SELECTORS.SCROLL];\r\n        const slider = DOMCache[Config.SVG.SELECTORS.PROGBAR];\r\n        \r\n        slider.max = StateManager.get('totalDistance') - 0.0000001;\r\n        scroll.children[0].style.height = `${slider.max}px`;\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}